<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandbox Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Add xterm.js dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xterm/5.5.0/xterm.js" integrity="sha512-Gujw5GajF5is3nMoGv9X+tCMqePLL/60qvAv1LofUZTV9jK8ENbM9L+maGmOsNzuZaiuyc/fpph1KT9uR5w3CQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/xterm/5.5.0/xterm.min.css" integrity="sha512-XpXUuzg5afNt1bsgnrOesXP70TLH8tXYYK5sK+Y0UV+YBvJn9EfRFYWy4HT3TVDfH0nl1CO0lwOxIrt2gk9qjg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        #terminal {
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body class="h-screen flex bg-gray-100">

    <!-- Sidebar -->
    <div class="w-1/4 bg-white shadow-md p-4 flex flex-col">
        <h2 class="text-lg font-semibold mb-2">Sandboxes</h2>
        <button class="bg-blue-500 text-white px-4 py-2 rounded mb-2 w-full"
                onclick="openCreateModal()">
            ‚ûï Create Sandbox
        </button>
        <label class="flex items-center text-sm text-gray-600 mb-4">
            <input type="checkbox" id="show-dead" class="mr-2" onchange="toggleDeadSandboxes()">
            Show terminated sandboxes
        </label>
        <ul id="sandbox-tree" class="space-y-2 flex-grow overflow-auto"></ul>
        
        <!-- Add user info section at bottom -->
        <div id="user-info" class="border-t pt-4 mt-4">
            <div class="flex items-center gap-3">
                <img id="user-avatar" class="w-8 h-8 rounded-full" src="" alt="User avatar">
                <span id="user-name" class="flex-grow text-sm font-medium"></span>
                <button onclick="logout()" class="text-red-500 hover:text-red-700 text-sm">
                    Logout
                </button>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="w-3/4 flex flex-col p-4">
        <h2 class="text-lg font-semibold">Sandbox Console</h2>

        <!-- Sandbox Status Bar -->
        <div id="sandbox-status" class="bg-gray-300 text-gray-800 p-2 rounded mt-2 text-sm flex justify-between items-center">
            <span id="sandbox-info">Select a sandbox to view status.</span>
            <div id="sandbox-actions" class="hidden space-x-2">
                <button class="bg-gray-500 text-white px-3 py-1 rounded text-sm" onclick="renameSandbox()">‚úè Rename</button>
                <button id="public-toggle" class="bg-purple-500 text-white px-3 py-1 rounded text-sm" onclick="togglePublic()">üîí Make Public</button>
                <button class="bg-red-500 text-white px-3 py-1 rounded text-sm" onclick="deleteSandbox()">‚ùå Stop</button>
                <button class="bg-purple-500 text-white px-3 py-1 rounded text-sm" onclick="forkSandbox()">üîÄ Fork</button>
            </div>
        </div>

        <!-- Error Alert -->
        <div id="error-alert" class="hidden bg-red-500 text-white p-3 rounded mt-2">
            <span id="error-message"></span>
            <button class="float-right font-bold" onclick="hideError()">‚úñ</button>
        </div>

        <!-- Tabs -->
        <div class="flex border-b mt-4">
            <button id="exec-tab" 
                    class="px-4 py-2 text-sm font-medium rounded-t-lg bg-white border-t border-l border-r"
                    onclick="switchTab('exec')">
                Command Execution
            </button>
            <button id="terminal-tab" 
                    class="px-4 py-2 text-sm font-medium rounded-t-lg border-t border-l border-r ml-2 bg-gray-100"
                    onclick="switchTab('terminal')">
                Terminal
            </button>
            <button id="logs-tab" 
                    class="px-4 py-2 text-sm font-medium rounded-t-lg border-t border-l border-r ml-2 bg-gray-100"
                    onclick="switchTab('logs')">
                Logs
            </button>
            <button id="http-tab" 
                    class="px-4 py-2 text-sm font-medium rounded-t-lg border-t border-l border-r ml-2 bg-gray-100"
                    onclick="switchTab('http')">
                HTTP
            </button>
        </div>

        <!-- Command Execution View -->
        <div id="exec-view" class="flex-grow flex flex-col">
            <div id="exec-results" class="flex-grow bg-gray-200 p-4 rounded mt-4 overflow-auto h-[60vh]">
                <p class="text-gray-500">Execution results will appear here.</p>
            </div>

            <!-- Command Input & Buttons -->
            <div class="bg-white p-4 shadow-md flex items-center gap-2">
                <textarea id="exec-code" class="border p-2 w-full h-12 resize-none" placeholder="Enter command..."
                          autocorrect="off" spellcheck="false" onkeydown="handleEnter(event)"></textarea>
                <button class="bg-green-500 text-white px-4 rounded" onclick="executeCode()">‚ñ∂ Run</button>
            </div>
        </div>

        <!-- Terminal View -->
        <div id="terminal-view" class="hidden flex-grow flex flex-col">
            <div id="terminal" class="flex-grow"></div>
        </div>

        <!-- Logs View -->
        <div id="logs-view" class="hidden flex-grow flex flex-col">
            <div id="sandbox-logs" class="flex-grow bg-gray-200 p-4 rounded mt-4 overflow-auto h-[calc(60vh+4rem)]">
                <p class="text-gray-500">Sandbox logs will appear here.</p>
            </div>
        </div>

        <!-- HTTP View -->
        <div id="http-view" class="hidden flex-grow flex flex-col">
            <div class="flex items-center gap-2 mt-4">
                <button class="text-gray-600 px-2 py-1 rounded hover:bg-gray-100" onclick="goBack()" title="Back">
                    ‚óÄ
                </button>
                <button class="text-gray-600 px-2 py-1 rounded hover:bg-gray-100" onclick="goForward()" title="Forward">
                    ‚ñ∂
                </button>
                <input type="text" id="url-bar" class="border p-2 flex-grow rounded" 
                       placeholder="Enter URL..." 
                       onkeydown="handleUrlEnter(event)">
                <button class="text-gray-600 px-2 py-1 rounded hover:bg-gray-100" onclick="refreshIframe()" title="Refresh">
                    ‚Üª
                </button>
                <button class="bg-blue-500 text-white px-4 py-2 rounded" onclick="navigateIframe()">Go</button>
            </div>
            <iframe id="sandbox-iframe" class="w-full flex-grow mt-4 border rounded" sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-storage-access-by-user-activation"></iframe>
        </div>

    </div>

    <!-- Create Sandbox Modal -->
    <div id="create-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex justify-center items-center">
        <div class="bg-white p-6 rounded shadow-md w-1/3">
            <h2 class="text-lg font-semibold">Create Sandbox</h2>

            <label class="block mt-2">Examples:</label>
            <select id="sandbox-examples" class="border p-2 w-full" onchange="populateExample()">
                <option value="">Select an example...</option>
                <option value="redis">Redis</option>
                <option value="nginx">Nginx</option>
                <option value="firefox">Firefox</option>
                <option value="bash">Bash</option>
            </select>

            <label class="block mt-2">Docker Image:</label>
            <input type="text" id="sandbox-image" class="border p-2 w-full" placeholder="e.g., python:3">

            <label class="block mt-2">Label:</label>
            <input type="text" id="sandbox-label" class="border p-2 w-full" placeholder="Sandbox Label">

            <label class="block mt-2">Container Arguments:</label>
            <textarea id="sandbox-args" 
                     class="border p-2 w-full h-24 font-mono text-sm" 
                     placeholder="Enter one argument per line, for example:&#10;redis-server&#10;--loglevel warning&#10;"></textarea>

            <label class="block mt-2">Environment Variables:</label>
            <textarea id="sandbox-env" 
                     class="border p-2 w-full h-24 font-mono text-sm" 
                     placeholder="Enter one environment variable per line, for example:&#10;POSTGRES_USER=foo&#10;POSTGRES_PASSWORD=bar&#10;"></textarea>

            <div class="mt-4 flex justify-between items-center">
                <label class="flex items-center text-sm text-gray-600">
                    <input type="checkbox" id="sandbox-interactive" class="mr-2">
                    Interactive (enable terminal)
                </label>
                <div class="flex">
                    <button class="bg-gray-500 text-white px-4 py-2 mr-2 rounded" onclick="closeCreateModal()" id="create-cancel-btn">Cancel</button>
                    <button class="bg-blue-500 text-white px-4 py-2 rounded flex items-center gap-2" onclick="createSandbox()" id="create-submit-btn">
                        <span>Create</span>
                        <div class="hidden" id="create-spinner">
                            <svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                        </div>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedSandbox = null;
        let logsInterval = null;
        let logsAbortController = null;
        let showDeadSandboxes = false;
        let term = null;
        let terminalWs = null;
        let terminalDataHandler = null;
        let currentTab = 'exec';

        // Add SSE connection management
        let eventSource = null;

        function connectSSE() {
            if (eventSource) {
                eventSource.close();
            }
            
            eventSource = new EventSource('/events');
            
            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('Received event:', data);
                
                // Refresh sandbox list when container events occur
                setTimeout(loadSandboxes, 500);
            };
            
            eventSource.onerror = function(error) {
                console.error('SSE Error:', error);
                eventSource.close();
                // Attempt to reconnect after a delay
                setTimeout(connectSSE, 5000);
            };
        }

        // Initialize terminal
        function initTerminal() {
            // Always dispose of existing terminal first
            if (term) {
                term.dispose();
                term = null;
            }
            
            // Create new terminal instance
            term = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#1e1e1e',
                    foreground: '#ffffff',
                    cursor: '#ffffff',
                    selection: '#264f78'
                }
            });
            term.open(document.getElementById('terminal'));
        }

        // Connect terminal to sandbox
        function connectTerminal() {
            if (!selectedSandbox) return;
            
            // Ensure terminal is initialized
            if (!term) {
                initTerminal();
            }
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/sandboxes/${selectedSandbox}/attach`;
            
            terminalWs = new WebSocket(wsUrl);
            
            terminalWs.onopen = () => {
                console.log('Terminal WebSocket connected');
            };
            
            terminalWs.onclose = () => {
                console.log('Terminal WebSocket disconnected');
                terminalWs = null;
            };
            
            terminalWs.onerror = (error) => {
                console.error('Terminal WebSocket error:', error);
                terminalWs = null;
            };
            
            terminalWs.onmessage = (event) => {
                if (event.data instanceof Blob) {
                    event.data.arrayBuffer().then(buffer => {
                        const data = new Uint8Array(buffer);
                        term.write(data);
                    });
                } else {
                    term.write(event.data);
                }
            };

            // Handle terminal input - store the handler reference
            terminalDataHandler = data => {
                if (terminalWs && terminalWs.readyState === WebSocket.OPEN) {
                    const encoder = new TextEncoder();
                    const binaryData = encoder.encode(data);
                    terminalWs.send(binaryData);
                }
            };
            term.onData(terminalDataHandler);
        }

        // Disconnect terminal
        function disconnectTerminal() {
            if (terminalWs) {
                terminalWs.close();
                terminalWs = null;
            }
            // Remove the data handler if it exists
            if (terminalDataHandler && term) {
                term.dispose();
                term = null;
                terminalDataHandler = null;
            }
        }

        async function loadSandboxes() {
            try {
                const response = await fetch("/sandboxes");
                if (!response.ok) throw new Error("Failed to fetch sandboxes.");
                const data = await response.json();
                document.getElementById("sandbox-tree").innerHTML = renderTree(data.sandboxes);
            } catch (error) {
                showError(error.message);
            }
        }

        function toggleDeadSandboxes() {
            showDeadSandboxes = document.getElementById("show-dead").checked;
            loadSandboxes();
        }

        function hasActiveChildren(sandbox, allSandboxes) {
            // Check if this sandbox has any active children
            if (sandbox.child_ids && sandbox.child_ids.length > 0) {
                for (const childId of sandbox.child_ids) {
                    const child = allSandboxes.find(s => s.id === childId.id);
                    if (child) {
                        // If child is active or has active children, return true
                        if (child.status !== "terminated" || hasActiveChildren(child, allSandboxes)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function shouldShowSandbox(sandbox, allSandboxes) {
            // Always show if showDeadSandboxes is true
            if (showDeadSandboxes) return true;
            
            // Show if sandbox is not terminated
            if (sandbox.status !== "terminated") return true;
            
            // Show if sandbox has active children
            return hasActiveChildren(sandbox, allSandboxes);
        }

        function renderTree(sandboxes, parentId = null) {
            let html = "";
            sandboxes.forEach(sb => {
                if (sb.parent_id === parentId) {
                    // Skip if we shouldn't show this sandbox
                    if (!shouldShowSandbox(sb, sandboxes)) {
                        return;
                    }
                    
                    const isTerminated = sb.status === "terminated";
                    const statusColor = isTerminated ? "text-red-500" : "text-blue-500";
                    const statusIcon = isTerminated ? "üíÄ" : "üì¶";
                    
                    html += `
                        <li class="pl-4">
                            <button class="${statusColor} font-semibold" onclick="selectSandbox('${sb.id}')">
                                ${statusIcon} ${sb.label || "Unnamed"} [${sb.id.slice(0, 6)}]
                            </button>
                            <ul>${renderTree(sandboxes, sb.id)}</ul>
                        </li>
                    `;
                }
            });
            return html;
        }

        async function selectSandbox(sandboxId) {
            // Cancel any existing log streams before switching sandboxes
            if (logsAbortController) {
                logsAbortController.abort();
                logsAbortController = null;
            }
            
            // Disconnect existing terminal connection
            disconnectTerminal();
            
            selectedSandbox = sandboxId;
            try {
                const response = await fetch(`/sandboxes/${sandboxId}`);
                if (!response.ok) throw new Error("Failed to fetch sandbox details.");
                const sb = await response.json();

                const isTerminated = sb.status === "terminated";
                const statusColor = isTerminated ? "text-red-500" : "text-gray-800";
                
                const sandboxInfo = document.getElementById("sandbox-info");
                sandboxInfo.innerHTML = 
                    `üì¶ ${sb.label || "Unnamed"} [${sb.id.slice(0, 6)}] | <span class="${statusColor}">Status: ${sb.status}</span> | IP: ${sb.ip_address || "N/A"}`;
                
                // Store the sandbox URL as a data attribute
                sandboxInfo.setAttribute("data-url", sb.url || "");

                // Show action buttons but disable them if terminated
                const actionsDiv = document.getElementById("sandbox-actions");
                actionsDiv.classList.remove("hidden");
                
                // Update button states
                const buttons = actionsDiv.querySelectorAll("button");
                buttons.forEach(button => {
                    if (isTerminated) {
                        button.disabled = true;
                        button.classList.add("opacity-50", "cursor-not-allowed");
                    } else {
                        button.disabled = false;
                        button.classList.remove("opacity-50", "cursor-not-allowed");
                    }
                });

                // Update public toggle button
                const publicToggle = document.getElementById("public-toggle");
                if (sb.is_public) {
                    publicToggle.innerHTML = "üîì Make Private";
                    publicToggle.classList.remove("bg-purple-500");
                    publicToggle.classList.add("bg-green-500");
                } else {
                    publicToggle.innerHTML = "üîí Make Public";
                    publicToggle.classList.remove("bg-green-500");
                    publicToggle.classList.add("bg-purple-500");
                }

                // Disable command execution controls if terminated
                const execCode = document.getElementById("exec-code");
                const runButton = document.querySelector("button[onclick='executeCode()']");
                if (isTerminated) {
                    execCode.disabled = true;
                    execCode.classList.add("bg-gray-100", "cursor-not-allowed");
                    runButton.disabled = true;
                    runButton.classList.add("opacity-50", "cursor-not-allowed");
                } else {
                    execCode.disabled = false;
                    execCode.classList.remove("bg-gray-100", "cursor-not-allowed");
                    runButton.disabled = false;
                    runButton.classList.remove("opacity-50", "cursor-not-allowed");
                }

                // Handle logs tab for interactive sandboxes
                const logsTab = document.getElementById("logs-tab");
                if (sb.interactive) {
                    logsTab.disabled = true;
                    logsTab.classList.add("opacity-50", "cursor-not-allowed");
                    logsTab.title = "Logs are disabled for interactive sandboxes";
                    // If currently on logs tab, switch to exec tab
                    if (currentTab === "logs") {
                        switchTab("exec");
                    }
                } else {
                    logsTab.disabled = false;
                    logsTab.classList.remove("opacity-50", "cursor-not-allowed");
                    logsTab.title = "";
                }

                // Handle terminal tab for non-interactive sandboxes
                const terminalTab = document.getElementById("terminal-tab");
                if (!sb.interactive) {
                    terminalTab.disabled = true;
                    terminalTab.classList.add("opacity-50", "cursor-not-allowed");
                    terminalTab.title = "Terminal is only available for interactive sandboxes";
                    // If currently on terminal tab, switch to exec tab
                    if (currentTab === "terminal") {
                        switchTab("exec");
                    }
                } else {
                    terminalTab.disabled = false;
                    terminalTab.classList.remove("opacity-50", "cursor-not-allowed");
                    terminalTab.title = "";
                }

                // Load historical command executions
                await loadCommandExecutions();
                
                // Start fetching logs if we're on the logs tab
                if (!document.getElementById("logs-view").classList.contains("hidden")) {
                    stopLogsFetching();
                    startLogsFetching();
                }

                // Initialize HTTP view if we're on the HTTP tab
                if (!document.getElementById("http-view").classList.contains("hidden")) {
                    initializeHttpView();
                }

                // Connect terminal if we're on the terminal tab
                if (!document.getElementById("terminal-view").classList.contains("hidden")) {
                    connectTerminal();
                }
            } catch (error) {
                showError(error.message);
            }
        }

        async function loadCommandExecutions() {
            if (!selectedSandbox) return;
            
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}/execution-logs`);
                if (!response.ok) throw new Error("Failed to fetch command executions");
                const data = await response.json();
                
                const resultsContainer = document.getElementById("exec-results");
                resultsContainer.innerHTML = ''; // Clear existing content
                
                // Display executions in chronological order (newest first)
                for (const execution of data.executions) {
                    // Create a new result div for this execution
                    const resultDiv = document.createElement("pre");
                    resultDiv.classList = "bg-black text-green-400 text-wrap p-2 rounded shadow my-2 overflow-auto";
                    
                    // Add command header
                    resultDiv.textContent = `> ${execution.command}`;
                    
                    // Add logs for this execution
                    for (const log of execution.logs) {
                        const logLine = document.createElement("div");
                        logLine.className = log.fd === 2 ? "text-red-500" : "text-green-500";
                        logLine.textContent = log.content;
                        resultDiv.appendChild(logLine);
                    }
                    
                    // Add exit code if available
                    if (execution.exit_code != 0) {
                        const exitLine = document.createElement("div");
                        //exitLine.className = "text-yellow-500";
                        exitLine.textContent = `üõë Process exited with code ${execution.exit_code}`;
                        resultDiv.appendChild(exitLine);
                    }
                    
                    resultsContainer.appendChild(resultDiv);
                }
                
                // Scroll to bottom
                setTimeout(function() {
                    resultsContainer.scrollTop = resultsContainer.scrollHeight;
                }, 10);
            } catch (error) {
                console.error("Error loading command executions:", error);
                document.getElementById("exec-results").innerHTML = 
                    `<div class="text-red-500">Error loading command executions: ${error.message}</div>`;
            }
        }

        const SANDBOX_EXAMPLES = {
            redis: {
                image: 'redis',
                label: 'Redis',
                args: ['redis-server'],
                env: {},
                interactive: false
            },
            nginx: {
                image: 'nginx',
                label: 'Nginx',
                args: [],
                env: {},
                interactive: false
            },
            firefox: {
                image: 'jlesage/firefox',
                label: 'Firefox',
                args: [],
                env: {},
                interactive: false
            },
            bash: {
                image: 'bash',
                label: 'Bash',
                args: [],
                env: {},
                interactive: true
            }
        };

        function populateExample() {
            const selected = document.getElementById('sandbox-examples').value;
            if (!selected) {
                // Clear all fields
                document.getElementById('sandbox-image').value = '';
                document.getElementById('sandbox-label').value = '';
                document.getElementById('sandbox-args').value = '';
                document.getElementById('sandbox-env').value = '';
                document.getElementById('sandbox-interactive').checked = false;
                return;
            }

            const example = SANDBOX_EXAMPLES[selected];
            document.getElementById('sandbox-image').value = example.image;
            document.getElementById('sandbox-label').value = example.label;
            document.getElementById('sandbox-args').value = example.args.join('\n');
            document.getElementById('sandbox-env').value = Object.entries(example.env)
                .map(([key, value]) => `${key}=${value}`)
                .join('\n');
            document.getElementById('sandbox-interactive').checked = example.interactive;
        }

        function setCreateLoading(isLoading) {
            const submitBtn = document.getElementById('create-submit-btn');
            const cancelBtn = document.getElementById('create-cancel-btn');
            const spinner = document.getElementById('create-spinner');
            
            submitBtn.disabled = isLoading;
            cancelBtn.disabled = isLoading;
            
            if (isLoading) {
                spinner.classList.remove('hidden');
                submitBtn.classList.add('opacity-75', 'cursor-not-allowed');
                cancelBtn.classList.add('opacity-75', 'cursor-not-allowed');
            } else {
                spinner.classList.add('hidden');
                submitBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                cancelBtn.classList.remove('opacity-75', 'cursor-not-allowed');
            }
        }

        async function createSandbox() {
            hideError();
            const image = document.getElementById('sandbox-image').value.trim();
            const label = document.getElementById('sandbox-label').value.trim();
            const interactive = document.getElementById('sandbox-interactive').checked;
            if (!image || !label) return showError("Please enter a Docker image and a label.");

            // Parse environment variables
            const envText = document.getElementById('sandbox-env').value.trim();
            const env = {};
            if (envText) {
                envText.split('\n').forEach(line => {
                    line = line.trim();
                    if (line) {
                        const [key, ...valueParts] = line.split('=');
                        const value = valueParts.join('='); // Rejoin in case value contains =
                        if (key && value) {
                            env[key.trim()] = value.trim();
                        }
                    }
                });
            }

            // Parse container arguments
            const argsText = document.getElementById('sandbox-args').value.trim();
            const args = argsText ? argsText.split('\n').filter(line => line.trim()) : [];

            try {
                setCreateLoading(true);
                const response = await fetch("/sandboxes", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ image, label, env, args, interactive })
                });

                if (!response.ok) throw new Error(await response.text());
                closeCreateModal();
                loadSandboxes();
            } catch (error) {
                showError(error.message);
                closeCreateModal();
            } finally {
                setCreateLoading(false);
            }
        }

        async function forkSandbox() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            try {
                const label = prompt("Enter label for the forked sandbox:");
                if (!label) return;
                const response = await fetch(`/sandboxes/${selectedSandbox}/fork`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ label })
                });

                if (!response.ok) throw new Error(await response.text());
                loadSandboxes();
            } catch (error) {
                showError(error.message);
            }
        }

        async function executeCode() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            const codeInput = document.getElementById("exec-code");
            const code = codeInput.value.trim();
            if (!code) return showError("Enter a command.");

            // Clear input field after pressing run
            codeInput.value = "";

            // Create a new result div for this execution
            const resultDiv = document.createElement("pre");
            resultDiv.classList = "bg-black text-green-400 text-wrap p-2 rounded shadow my-2 overflow-auto";
            // Escape the code before displaying
            resultDiv.textContent = `> ${code}`;
            document.getElementById("exec-results").append(resultDiv);

            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}/execute?stream=true`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ code })
                });

                if (!response.ok || !response.body) throw new Error("Failed to stream execution.");

                // Stream processing
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });

                    // Process complete lines (JSON objects)
                    let lines = buffer.split("\n");
                    buffer = lines.pop(); // Save incomplete line for next read

                    for (let line of lines) {
                        try {
                            const data = JSON.parse(line.trim());
                            if (data.type === "stdout" || data.type === "stderr") {
                                // Append text safely
                                resultDiv.appendChild(document.createTextNode("\n" + data.output));
                            } else if (data.type === "exit" && data.exit_code != 0) {
                                resultDiv.innerHTML += `\nüõë ${data.output}`;
                            }
                        } catch (err) {
                            console.warn("Error parsing streamed JSON:", line, err);
                        }
                    }

                    // Scroll to the bottom when new results appear
                    document.getElementById("exec-results").scrollTop = document.getElementById("exec-results").scrollHeight;
                }
            } catch (error) {
                showError(error.message);
            }
        }

        async function deleteSandbox() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            if (!confirm("Are you sure you want to stop this sandbox?")) return;
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}`, { method: "DELETE" });
                if (!response.ok) throw new Error(await response.text());
                
                // Reset UI state
                selectedSandbox = null;
                const sandboxInfo = document.getElementById("sandbox-info");
                sandboxInfo.innerText = "Select a sandbox to view status.";
                sandboxInfo.removeAttribute("data-url");
                document.getElementById("sandbox-actions").classList.add("hidden");
                document.getElementById("exec-results").innerHTML = "";
                document.getElementById("sandbox-logs").innerHTML = "<p class='text-gray-500'>Sandbox logs will appear here.</p>";
                
                // Stop any active log streaming
                stopLogsFetching();
                
                // Reset HTTP view if active
                document.getElementById("sandbox-iframe").src = "";
                document.getElementById("url-bar").value = "";
                
                // Refresh sandbox list
                loadSandboxes();
            } catch (error) {
                showError(error.message);
            }
        }

        async function renameSandbox() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            const newLabel = prompt("Enter new label:");
            if (!newLabel) return;
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}`, {
                    method: "PATCH",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ label: newLabel })
                });

                if (!response.ok) throw new Error(await response.text());
                loadSandboxes();
            } catch (error) {
                showError(error.message);
            }
        }

        function handleEnter(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault();
                executeCode();
            }
        }

        function showError(message) {
            document.getElementById("error-message").innerText = message;
            document.getElementById("error-alert").classList.remove("hidden");
        }

        function hideError() {
            document.getElementById("error-alert").classList.add("hidden");
        }

        function openCreateModal() { document.getElementById("create-modal").classList.remove("hidden"); }
        function closeCreateModal() { document.getElementById("create-modal").classList.add("hidden"); }

        function switchTab(tab) {
            if (currentTab === tab) {
                return; // Ignore if clicking the same tab
            }
            currentTab = tab; // Update current tab

            // Update tab styling
            document.getElementById("exec-tab").classList.toggle("bg-white", tab === "exec");
            document.getElementById("exec-tab").classList.toggle("bg-gray-100", tab !== "exec");
            document.getElementById("terminal-tab").classList.toggle("bg-white", tab === "terminal");
            document.getElementById("terminal-tab").classList.toggle("bg-gray-100", tab !== "terminal");
            document.getElementById("logs-tab").classList.toggle("bg-white", tab === "logs");
            document.getElementById("logs-tab").classList.toggle("bg-gray-100", tab !== "logs");
            document.getElementById("http-tab").classList.toggle("bg-white", tab === "http");
            document.getElementById("http-tab").classList.toggle("bg-gray-100", tab !== "http");

            // Show/hide content
            document.getElementById("exec-view").classList.toggle("hidden", tab !== "exec");
            const terminalView = document.getElementById("terminal-view");
            const terminal = document.getElementById("terminal");
            terminalView.classList.toggle("hidden", tab !== "terminal");
            terminal.classList.toggle("hidden", tab !== "terminal");
            document.getElementById("logs-view").classList.toggle("hidden", tab !== "logs");
            document.getElementById("http-view").classList.toggle("hidden", tab !== "http");

            // Handle terminal tab
            if (tab === "terminal") {
                if (!term) {
                    initTerminal();
                }
                if (selectedSandbox) {
                    connectTerminal();
                }
            } else {
                disconnectTerminal();
            }

            // Handle logs fetching
            if (tab === "logs" && selectedSandbox) {
                startLogsFetching();
            } else {
                stopLogsFetching();
            }

            // Handle HTTP tab initialization
            if (tab === "http" && selectedSandbox) {
                initializeHttpView();
            }
        }

        function initializeHttpView() {
            const urlBar = document.getElementById("url-bar");
            const sandboxInfo = document.getElementById("sandbox-info");
            const sandboxUrl = sandboxInfo.getAttribute("data-url");
            
            if (sandboxUrl) {
                urlBar.value = sandboxUrl;
            } else {
                urlBar.value = "";
            }
            
            navigateIframe();
        }

        function navigateIframe() {
            if (!selectedSandbox) return;
            
            // Get the sandbox URL from the sandbox info
            const sandboxInfo = document.getElementById("sandbox-info");
            const sandboxUrl = sandboxInfo.getAttribute("data-url");
            
            if (!sandboxUrl) {
                document.getElementById("sandbox-iframe").src = "";
                return;
            }
            
            const urlBar = document.getElementById("url-bar");
            const userPath = urlBar.value;
            
            // If the user has modified the URL bar to a different domain, use that
            if (userPath.startsWith("http://") || userPath.startsWith("https://")) {
                document.getElementById("sandbox-iframe").src = userPath;
                return;
            }
            
            // Otherwise, use the sandbox URL
            document.getElementById("sandbox-iframe").src = sandboxUrl;
        }

        async function fetchLogs() {
            if (!selectedSandbox) return;
            
            // Create new AbortController for this stream
            logsAbortController = new AbortController();
            
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}/logs?stream=true`, {
                    signal: logsAbortController.signal
                });
                if (!response.ok || !response.body) throw new Error("Failed to stream logs");

                // Create logs container if it doesn't exist
                const logsContainer = document.getElementById("sandbox-logs");
                logsContainer.innerHTML = ''; // Clear existing content
                const preElement = document.createElement('pre');
                preElement.className = "text-sm font-mono whitespace-pre-wrap";
                logsContainer.appendChild(preElement);

                // Stream processing
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });

                    // Process complete lines
                    let lines = buffer.split("\n");
                    buffer = lines.pop() || ""; // Save incomplete line for next read

                    // Append each complete line to the logs
                    for (let line of lines) {
                        // Append text safely
                        preElement.appendChild(document.createTextNode(line + "\n"));
                        logsContainer.scrollTop = logsContainer.scrollHeight;
                    }
                }

                // Handle any remaining buffer
                if (buffer) {
                    preElement.appendChild(document.createTextNode(buffer));
                    logsContainer.scrollTop = logsContainer.scrollHeight;
                }
            } catch (error) {
                console.error("Error streaming logs:", error);
                document.getElementById("sandbox-logs").textContent = 
                    `Error streaming logs: ${error.message}`;
            }
        }

        function startLogsFetching() {
            stopLogsFetching(); // Clear any existing streams
            fetchLogs(); // Start streaming
        }

        function stopLogsFetching() {
            if (logsAbortController) {
                logsAbortController.abort();
                logsAbortController = null;
            }
        }

        function handleUrlEnter(event) {
            if (event.key === "Enter") {
                event.preventDefault();
                navigateIframe();
            }
        }

        function goBack() {
            const iframe = document.getElementById("sandbox-iframe");
            iframe.contentWindow.history.back();
            // Update URL bar after navigation
            setTimeout(() => {
                const urlBar = document.getElementById("url-bar");
                urlBar.value = iframe.contentWindow.location.href;
            }, 100);
        }

        function goForward() {
            const iframe = document.getElementById("sandbox-iframe");
            iframe.contentWindow.history.forward();
            // Update URL bar after navigation
            setTimeout(() => {
                const urlBar = document.getElementById("url-bar");
                urlBar.value = iframe.contentWindow.location.href;
            }, 100);
        }

        function refreshIframe() {
            const iframe = document.getElementById("sandbox-iframe");
            iframe.contentWindow.location.reload();
            // Update URL bar after refresh
            setTimeout(() => {
                const urlBar = document.getElementById("url-bar");
                urlBar.value = iframe.contentWindow.location.href;
            }, 100);
        }

        async function loadUserInfo() {
            try {
                const response = await fetch('/auth/me');
                if (!response.ok) throw new Error('Failed to fetch user info');
                const user = await response.json();
                
                document.getElementById('user-avatar').src = user.avatar_url;
                document.getElementById('user-name').textContent = user.name;
            } catch (error) {
                console.error('Error loading user info:', error);
                // Redirect to login if unauthorized
                if (error.response?.status === 401) {
                    window.location.href = '/';
                }
            }
        }

        async function logout() {
            try {
                const response = await fetch('/auth/logout', { method: 'POST' });
                if (response.ok) {
                    window.location.href = '/';
                }
            } catch (error) {
                console.error('Error logging out:', error);
            }
        }

        async function togglePublic() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}`);
                if (!response.ok) throw new Error("Failed to fetch sandbox details.");
                const sb = await response.json();
                
                const newPublicState = !sb.is_public;
                const action = newPublicState ? "make public" : "make private";
                
                if (!confirm(`Are you sure you want to ${action} this sandbox?`)) return;
                
                const updateResponse = await fetch(`/sandboxes/${selectedSandbox}`, {
                    method: "PATCH",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ public: newPublicState })
                });

                if (!updateResponse.ok) throw new Error(await updateResponse.text());
                
                // Refresh sandbox details to update UI
                selectSandbox(selectedSandbox);
            } catch (error) {
                showError(error.message);
            }
        }

        // Connect to SSE when page loads
        document.addEventListener('DOMContentLoaded', function() {
            connectSSE();
            loadSandboxes();
            loadUserInfo();
            
            // Add event listener to iframe to update URL bar when URL changes
            const iframe = document.getElementById("sandbox-iframe");
            iframe.addEventListener('load', function() {
                const urlBar = document.getElementById("url-bar");
                urlBar.value = iframe.contentWindow.location.href;
            });
        });

        // Clean up SSE connection when page unloads
        window.addEventListener('beforeunload', function() {
            if (eventSource) {
                eventSource.close();
            }
        });
    </script>
</body>
</html>