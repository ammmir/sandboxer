<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandbox Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet" type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@5/themes.css" rel="stylesheet" type="text/css" />
    <!-- Add xterm.js dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xterm/5.5.0/xterm.js" integrity="sha512-Gujw5GajF5is3nMoGv9X+tCMqePLL/60qvAv1LofUZTV9jK8ENbM9L+maGmOsNzuZaiuyc/fpph1KT9uR5w3CQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/xterm/5.5.0/xterm.min.css" integrity="sha512-XpXUuzg5afNt1bsgnrOesXP70TLH8tXYYK5sK+Y0UV+YBvJn9EfRFYWy4HT3TVDfH0nl1CO0lwOxIrt2gk9qjg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.min.js"></script>
    <style>
        #terminal {
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #terminal-view {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .xterm-viewport {
            overflow-y: auto !important;
        }
    </style>
</head>
<body class="h-screen flex bg-base-100">
    <!-- Theme Toggle not used yet-->
    <!--
    <button class="theme-toggle btn btn-ghost btn-sm btn-circle fixed top-1 right-1" onclick="toggleTheme()" title="Toggle theme">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
        </svg>
    </button>
    -->

    <!-- Sidebar -->
    <div class="w-1/4 bg-base-200 shadow-md p-4 flex flex-col h-screen">
        <div class="sticky top-0">
            <h2 class="text-lg font-semibold mb-2">Sandboxes</h2>
            <button class="btn mb-2 w-full flex items-center justify-center gap-2 hover:bg-primary-focus transition-colors duration-200"
                    onclick="openCreateModal()">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                </svg>
                Create Sandbox
            </button>
            <label class="label cursor-pointer">
                <input type="checkbox" id="show-dead" class="checkbox checkbox-sm" onchange="toggleDeadSandboxes()">
                <span class="label-text text-sm">Show terminated sandboxes</span>
            </label>
        </div>

        <div class="flex-1 overflow-y-auto">
            <ul id="sandbox-tree" class="space-y-2 flex-1 overflow-auto"></ul>
        </div>
        
        <div>
            <!-- File System Explorer -->
            <div id="file-explorer" class="border-t border-base-300 pt-4 mt-4 hidden flex flex-col w-full" 
                ondragover="handleDragOver(event)" 
                ondragleave="handleDragLeave(event)" 
                ondrop="handleDrop(event)">
                <div class="flex join items-center mb-2">
                    <button onclick="navigateUp()" class="btn btn-sm join-item" title="Go up">
                        â¬†
                    </button>
                    <button onclick="loadFileSystem(document.getElementById('current-path').value)" class="btn btn-sm join-item" title="Refresh directory">
                        â†»
                    </button>
                    <input type="file" id="file-upload" class="hidden" webkitdirectory multiple>
                    <input type="text" id="current-path" class="input input-bordered input-sm flex-grow" 
                        onkeydown="handlePathInput(event)" placeholder="Enter path... (âŒ˜P to focus)">
                    <button onclick="document.getElementById('file-upload').click()" class="btn btn-sm join-item" title="Upload files">
                        ðŸ“¤
                    </button>
                </div>
                <div class="w-full h-64">
                    <ul id="file-list" class="menu menu-xs rounded-box w-full h-full overflow-y-auto overflow-x-hidden grid grid-cols-2 gap-0 auto-rows-min"
                        ondragover="handleDragOver(event)" 
                        ondragleave="handleDragLeave(event)" 
                        ondrop="handleDrop(event)">
                        <p class="text-base-content/70 p-2">Select a sandbox to view files.</p>
                    </ul>
                </div>
            </div>
            
            <!-- Add user info section at bottom -->
            <div id="user-info" class="border-t border-base-300 pt-4 mt-4 bg-base-200">
                <div class="flex items-center gap-3">
                    <img id="user-avatar" class="w-8 h-8 rounded-full" src="" alt="User avatar">
                    <span id="user-name" class="flex-grow text-sm font-medium"></span>
                    <button onclick="logout()" class="btn btn-ghost btn-sm text-error">
                        Logout
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="w-3/4 flex flex-col p-4">
        <h2 class="text-lg font-semibold">Sandbox Console</h2>

        <!-- Sandbox Status Bar -->
        <div id="sandbox-status" class="bg-base-200 p-2 rounded mt-2 text-sm flex justify-between items-center">
            <div id="sandbox-info" class="flex-grow">Select a sandbox to view status.</div>
            <ul id="sandbox-actions"class="join menu menu-horizontal bg-base-200 rounded-box">
                <li>
                    <button onclick="renameSandbox()" title="Rename">
                        <img src="/static/images/icon-rename.svg" alt="Rename" class="w-5 h-5">
                    </button>
                </li>
                <li>
                    <button id="public-toggle" onclick="togglePublic()" title="Make Public">
                        <img src="/static/images/icon-public.svg" alt="Public" class="w-5 h-5">
                    </button>
                </li>
                <li>
                    <button id="pause-toggle" onclick="togglePause()" title="Pause">
                        <img src="/static/images/icon-pause.svg" alt="Pause" class="w-5 h-5">
                    </button>
                </li>
                <li>
                    <button onclick="deleteSandbox()" title="Terminate">
                        <img src="/static/images/icon-delete.svg" alt="Delete" class="w-5 h-5">
                    </button>
                </li>
                <li>
                    <button onclick="forkSandbox()" title="Fork">
                        <img src="/static/images/icon-fork.svg" alt="Fork" class="w-5 h-5">
                    </button>
                </li>
            </ul>
        </div>

        <!-- Error Alert -->
        <div id="error-alert" class="hidden alert alert-error mt-2">
            <span id="error-message"></span>
            <button class="float-right font-bold" onclick="hideError()">âœ–</button>
        </div>

        <!-- Tabs -->
        <div role="tablist" class="tabs tabs-lift mt-4">
            <a role="tab" id="exec-tab" 
                    class="tab tab-active"
                    onclick="switchTab('exec')">
                Command Execution
            </a>
            <a role="tab" id="terminal-tab" 
                    class="tab"
                    onclick="switchTab('terminal')">
                Terminal
            </a>
            <a role="tab" id="logs-tab" 
                    class="tab"
                    onclick="switchTab('logs')">
                Logs
            </a>
            <a role="tab" id="http-tab" 
                    class="tab"
                    onclick="switchTab('http')">
                HTTP
            </a>
        </div>

        <!-- Command Execution View -->
        <div id="exec-view" class="flex-grow flex flex-col">
            <div id="exec-results" class="flex-grow bg-base-200 p-4 rounded mt-4 overflow-auto h-[60vh]">
                <p class="text-base-content/70">Execution results will appear here.</p>
            </div>

            <!-- Command Input & Buttons -->
            <div class="bg-base-100 p-4 shadow-md flex items-center gap-2">
                <textarea id="exec-code" class="textarea textarea-bordered w-full h-12 resize-none" placeholder="Enter command..."
                          autocorrect="off" spellcheck="false" onkeydown="handleEnter(event)"></textarea>
                <button class="btn flex items-center justify-center gap-2 hover:bg-primary-focus transition-colors duration-200" onclick="executeCode()">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    Run
                </button>
            </div>
        </div>

        <!-- Terminal View -->
        <div id="terminal-view" class="hidden flex-grow flex flex-col">
            <div id="terminal" class="flex-grow"></div>
        </div>

        <!-- Logs View -->
        <div id="logs-view" class="hidden flex-grow flex flex-col">
            <div id="sandbox-logs" class="flex-grow bg-base-200 p-4 rounded mt-4 overflow-auto h-[calc(60vh+4rem)]">
                <p class="text-base-content/70">Sandbox logs will appear here.</p>
            </div>
        </div>

        <!-- HTTP View -->
        <div id="http-view" class="hidden flex-grow flex flex-col h-full">
            <div class="mockup-browser border border-base-300 w-full h-full flex flex-col">
                <div class="mockup-browser-toolbar">
                    <input type="text" id="browser-url" class="input input-sm w-full" 
                           placeholder="https://" 
                           onkeydown="handleBrowserUrlEnter(event)"
                           onblur="handleBrowserUrlBlur(event)">
                </div>
                <div class="flex-grow bg-base-100" id="sandbox-iframe-container">
                    <iframe id="sandbox-iframe" class="w-full h-full border-0" sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-storage-access-by-user-activation"></iframe>
                </div>
            </div>
        </div>

    </div>

    <!-- Create Sandbox Modal -->
    <dialog id="create-modal" class="modal">
        <div class="modal-box w-11/12 max-w-3xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-semibold">Create Sandbox</h2>
                <div class="dropdown dropdown-end">
                    <details>
                        <summary class="btn btn-ghost btn-sm">Examples</summary>
                        <ul class="dropdown-content z-[1] menu p-2 shadow bg-base-100 rounded-box w-52">
                            <li><a onclick="populateExample('redis'); this.closest('details').removeAttribute('open')">Redis</a></li>
                            <li><a onclick="populateExample('nginx'); this.closest('details').removeAttribute('open')">Nginx</a></li>
                            <li><a onclick="populateExample('firefox'); this.closest('details').removeAttribute('open')">Firefox</a></li>
                            <li><a onclick="populateExample('bash'); this.closest('details').removeAttribute('open')">Bash</a></li>
                            <li><a onclick="populateExample('fresh'); this.closest('details').removeAttribute('open')">Fresh (Deno)</a></li>
                        </ul>
                    </details>
                </div>
            </div>

            <div class="flex gap-4 mb-4">
                <div class="form-control flex-1">
                    <label class="label">
                        <span class="label-text">Docker Image</span>
                    </label>
                    <input type="text" id="sandbox-image" class="input input-bordered w-full" placeholder="e.g., python:3">
                </div>
                <div class="form-control flex-1">
                    <label class="label">
                        <span class="label-text">Label</span>
                    </label>
                    <input type="text" id="sandbox-label" class="input input-bordered w-full" placeholder="Sandbox Label">
                </div>
                <div class="form-control flex-1">
                    <label class="label">
                        <span class="label-text">Hostname (optional)</span>
                    </label>
                    <input type="text" id="sandbox-hostname" class="input input-bordered w-full" placeholder="Auto-assigned if blank">
                </div>
            </div>

            <div class="form-control mb-4">
                <label class="label">
                    <span class="label-text">Container Arguments</span>
                </label>
                <textarea id="sandbox-args" 
                         class="textarea textarea-bordered w-full h-24 font-mono text-sm" 
                         placeholder="Enter one argument per line, for example:&#10;redis-server&#10;--loglevel warning&#10;"></textarea>
            </div>

            <div class="form-control mb-4">
                <label class="label">
                    <span class="label-text">Environment Variables</span>
                </label>
                <textarea id="sandbox-env" 
                         class="textarea textarea-bordered w-full h-24 font-mono text-sm" 
                         placeholder="Enter one environment variable per line, for example:&#10;POSTGRES_USER=foo&#10;POSTGRES_PASSWORD=bar&#10;"></textarea>
            </div>

            <div class="mt-4 flex justify-between items-center">
                <label class="label cursor-pointer">
                    <span class="label-text">Interactive (enable terminal)</span>
                    <input type="checkbox" id="sandbox-interactive" class="checkbox">
                </label>
                <div class="flex gap-2">
                    <button class="btn" onclick="closeCreateModal()" id="create-cancel-btn">Cancel</button>
                    <button class="btn btn-neutral flex items-center gap-2" onclick="createSandbox()" id="create-submit-btn">
                        <span>Create</span>
                        <div class="hidden" id="create-spinner">
                            <span class="loading loading-spinner loading-sm"></span>
                        </div>
                    </button>
                </div>
            </div>
        </div>
        <form method="dialog" class="modal-backdrop">
            <button>close</button>
        </form>
    </dialog>

    <script>
        let selectedSandbox = null;
        let logsInterval = null;
        let logsAbortController = null;
        let showDeadSandboxes = false;
        let term = null;
        let terminalWs = null;
        let terminalDataHandler = null;
        let currentTab = 'exec';
        let terminalResizeObserver = null;  // Add variable to store the observer

        // Add SSE connection management
        let eventSource = null;

        function connectSSE() {
            if (eventSource) {
                eventSource.close();
            }
            
            eventSource = new EventSource('/events');
            
            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('Received event:', data);
                
                // Check if the current sandbox has terminated
                if (selectedSandbox && data.container_id === selectedSandbox && data.type === 'container_stopped') {
                    // Reset the view as if we had manually terminated it
                    selectedSandbox = null;
                    const sandboxInfo = document.getElementById("sandbox-info");
                    sandboxInfo.innerText = "Select a sandbox to view status.";
                    sandboxInfo.removeAttribute("data-url");
                    document.getElementById("sandbox-actions").classList.add("hidden");
                    
                    // Clear all tab contents
                    document.getElementById("exec-results").innerHTML = "<p class='text-base-content/70'>Execution results will appear here.</p>";
                    document.getElementById("sandbox-logs").innerHTML = "<p class='text-base-content/70'>Sandbox logs will appear here.</p>";
                    document.getElementById("exec-code").value = "";
                    document.getElementById("exec-code").disabled = false;
                    document.getElementById("exec-code").classList.remove("bg-base-200", "cursor-not-allowed");
                    
                    // Reset terminal
                    disconnectTerminal();
                    if (term) {
                        term.dispose();
                        term = null;
                    }
                    
                    // Reset HTTP view
                    document.getElementById("sandbox-iframe").src = "";
                    document.getElementById("browser-url").value = "";
                    
                    // Reset file explorer
                    document.getElementById("file-explorer").classList.add("hidden");
                    document.getElementById("file-list").innerHTML = "<p class='text-base-content/70 p-2'>Select a sandbox to view files.</p>";
                    document.getElementById("current-path").value = "";
                    
                    // Switch back to exec tab
                    switchTab('exec');
                }
                
                // Refresh sandbox list when container events occur
                setTimeout(loadSandboxes, 500);
            };
            
            eventSource.onerror = function(error) {
                console.error('SSE Error:', error);
                eventSource.close();
                // Attempt to reconnect after a delay
                setTimeout(connectSSE, 5000);
            };
        }

        // Initialize terminal
        function initTerminal() {
            // Always dispose of existing terminal first
            if (term) {
                term.dispose();
                term = null;
            }
            
            // Clean up existing resize observer if any
            if (terminalResizeObserver) {
                terminalResizeObserver.disconnect();
                terminalResizeObserver = null;
            }
            
            // Create new terminal instance
            term = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#1e1e1e',
                    foreground: '#ffffff',
                    cursor: '#ffffff',
                    selection: '#264f78'
                },
                scrollback: 1000,
                rows: 24,
                cols: 80
            });
            term.open(document.getElementById('terminal'));
            
            // Load and apply the fit addon
            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            
            fitAddon.fit();
            
            window.addEventListener('resize', () => {
                fitAddon.fit();
            });
        }

        // Connect terminal to sandbox
        function connectTerminal() {
            if (!selectedSandbox) return;
            
            // Ensure terminal is initialized
            if (!term) {
                initTerminal();
            }
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/sandboxes/${selectedSandbox}/attach`;
            
            terminalWs = new WebSocket(wsUrl);
            
            terminalWs.onopen = () => {
                console.log('Terminal WebSocket connected');
            };
            
            terminalWs.onclose = () => {
                console.log('Terminal WebSocket disconnected');
                terminalWs = null;
            };
            
            terminalWs.onerror = (error) => {
                console.error('Terminal WebSocket error:', error);
                terminalWs = null;
            };
            
            terminalWs.onmessage = (event) => {
                if (event.data instanceof Blob) {
                    event.data.arrayBuffer().then(buffer => {
                        const data = new Uint8Array(buffer);
                        term.write(data);
                    });
                } else {
                    term.write(event.data);
                }
            };

            // Handle terminal input - store the handler reference
            terminalDataHandler = data => {
                if (terminalWs && terminalWs.readyState === WebSocket.OPEN) {
                    const encoder = new TextEncoder();
                    const binaryData = encoder.encode(data);
                    terminalWs.send(binaryData);
                }
            };
            term.onData(terminalDataHandler);
        }

        // Disconnect terminal
        function disconnectTerminal() {
            if (terminalWs) {
                terminalWs.close();
                terminalWs = null;
            }
            // Remove the data handler if it exists
            if (terminalDataHandler && term) {
                term.dispose();
                term = null;
                terminalDataHandler = null;
            }
            // Clean up resize observer
            if (terminalResizeObserver) {
                terminalResizeObserver.disconnect();
                terminalResizeObserver = null;
            }
        }

        async function loadSandboxes() {
            try {
                const response = await fetch("/sandboxes");
                if (!response.ok) throw new Error("Failed to fetch sandboxes.");
                const data = await response.json();
                const treeContainer = document.getElementById("sandbox-tree");
                treeContainer.className = "menu bg-base-200 rounded-box w-full";
                treeContainer.innerHTML = renderTree(data.sandboxes);
            } catch (error) {
                showError(error.message);
            }
        }

        function toggleDeadSandboxes() {
            showDeadSandboxes = document.getElementById("show-dead").checked;
            loadSandboxes();
        }

        function hasActiveChildren(sandbox, allSandboxes) {
            // Check if this sandbox has any active children
            if (sandbox.child_ids && sandbox.child_ids.length > 0) {
                for (const childId of sandbox.child_ids) {
                    const child = allSandboxes.find(s => s.id === childId.id);
                    if (child) {
                        // If child is active or has active children, return true
                        if (child.status !== "terminated" || hasActiveChildren(child, allSandboxes)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function shouldShowSandbox(sandbox, allSandboxes) {
            // Always show if showDeadSandboxes is true
            if (showDeadSandboxes) return true;
            
            // Show if sandbox is not terminated
            if (sandbox.status !== "terminated") return true;
            
            // Show if sandbox has active children
            return hasActiveChildren(sandbox, allSandboxes);
        }

        function renderTree(sandboxes, parentId = null) {
            let html = "";
            sandboxes.forEach(sb => {
                if (sb.parent_id === parentId) {
                    // Skip if we shouldn't show this sandbox
                    if (!shouldShowSandbox(sb, sandboxes)) {
                        return;
                    }
                    
                    // Add status indicator
                    const statusDiv = document.createElement("div");
                    statusDiv.setAttribute("aria-label", "status");
                    statusDiv.className = "status";
                    
                    if (sb.status === "terminated") {
                        statusDiv.classList.add("status-error");
                        statusDiv.setAttribute("aria-label", "error");
                    } else if (sb.status === "paused") {
                        statusDiv.classList.add("status-warning");
                        statusDiv.setAttribute("aria-label", "warning");
                    } else if (sb.status === "stopped") {
                        statusDiv.classList.add("status-neutral");
                    } else {
                        statusDiv.classList.add("status-success");
                    }
                    
                    const hasChildren = sandboxes.some(child => child.parent_id === sb.id);
                    const childrenHtml = hasChildren ? renderTree(sandboxes, sb.id) : '';
                    
                    html += `
                        <li>
                            <a onclick="selectSandbox('${sb.id}')" class="${selectedSandbox === sb.id ? 'menu-active' : ''}">
                                <div class="flex items-center gap-2">
                                    ${statusDiv.outerHTML}
                                    <span>${sb.label || "Unnamed"}</span>
                                </div>
                            </a>
                            ${childrenHtml ? `<ul>${childrenHtml}</ul>` : ''}
                        </li>
                    `;
                }
            });
            return html;
        }

        async function selectSandbox(sandboxId) {
            // Cancel any existing log streams before switching sandboxes
            if (logsAbortController) {
                logsAbortController.abort();
                logsAbortController = null;
            }
            
            // Disconnect existing terminal connection
            disconnectTerminal();
            
            selectedSandbox = sandboxId;
            
            // Update active state in the tree
            const treeItems = document.querySelectorAll('#sandbox-tree a');
            treeItems.forEach(item => {
                item.classList.remove('menu-active');
                if (item.getAttribute('onclick').includes(sandboxId)) {
                    item.classList.add('menu-active');
                }
            });
            
            try {
                const response = await fetch(`/sandboxes/${sandboxId}`);
                if (!response.ok) throw new Error("Failed to fetch sandbox details.");
                const sb = await response.json();

                const isTerminated = sb.status === "terminated";


                const sandboxInfo = document.getElementById("sandbox-info");
                sandboxInfo.innerHTML = ''; // Clear existing content
                
                // Create first line container
                const firstLine = document.createElement("div");
                firstLine.className = "flex items-center gap-2";
                
                // Add status indicator
                const statusDiv = document.createElement("div");
                statusDiv.setAttribute("aria-label", "status");
                statusDiv.className = "status";
                
                if (sb.status === "terminated") {
                    statusDiv.classList.add("status-error");
                    statusDiv.setAttribute("aria-label", "error");
                } else if (sb.status === "paused") {
                    statusDiv.classList.add("status-warning");
                    statusDiv.setAttribute("aria-label", "warning");
                } else if (sb.status === "stopped") {
                    statusDiv.classList.add("status-neutral");
                } else {
                    statusDiv.classList.add("status-success");
                }
                
                // Add sandbox name
                const nameSpan = document.createElement("span");
                nameSpan.textContent = `${sb.label || "Unnamed"}`;
                
                firstLine.appendChild(statusDiv);
                firstLine.appendChild(nameSpan);
                
                // Create second line container
                const secondLine = document.createElement("div");
                secondLine.className = "text-sm text-base-content/70 flex items-center gap-2";
                
                // Add hostname
                const hostnameSpan = document.createElement("span");
                hostnameSpan.textContent = `Hostname: ${sb.hostname || "N/A"}`;
                
                // Add copy button
                const copyButton = document.createElement("button");
                copyButton.className = "btn btn-ghost btn-xs p-0";
                copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" /></svg>';
                copyButton.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    navigator.clipboard.writeText(sb.hostname || "");
                };
                
                secondLine.appendChild(hostnameSpan);
                secondLine.appendChild(copyButton);
                
                // Add both lines to sandboxInfo
                sandboxInfo.appendChild(firstLine);
                sandboxInfo.appendChild(secondLine);
                
                // Store the sandbox URL as a data attribute
                sandboxInfo.setAttribute("data-url", sb.url || "");
                sandboxInfo.setAttribute("data-status", sb.status);

                // Show action buttons but disable them if terminated
                const actionsDiv = document.getElementById("sandbox-actions");
                actionsDiv.classList.remove("hidden");
                
                // Update button states
                const buttons = actionsDiv.querySelectorAll("button");
                buttons.forEach(button => {
                    if (isTerminated) {
                        button.disabled = true;
                        button.classList.add("opacity-50", "cursor-not-allowed");
                    } else {
                        button.disabled = false;
                        button.classList.remove("opacity-50", "cursor-not-allowed");
                    }
                });

                // Update public toggle button
                const publicToggle = document.getElementById("public-toggle");
                if (sb.is_public) {
                    publicToggle.querySelector('img').src = '/static/images/icon-public.svg';
                    publicToggle.classList.remove("btn-ghost");
                    publicToggle.classList.add("btn-primary");
                } else {
                    publicToggle.querySelector('img').src = '/static/images/icon-private.svg';
                    publicToggle.classList.remove("btn-primary");
                    publicToggle.classList.add("btn-ghost");
                }

                // Update pause toggle button
                const pauseToggle = document.getElementById("pause-toggle");
                pauseToggle.querySelector('img').src = sb.status === "paused" ? 
                    '/static/images/icon-play.svg' : '/static/images/icon-pause.svg';

                // Disable command execution controls if terminated
                const execCode = document.getElementById("exec-code");
                const runButton = document.querySelector("button[onclick='executeCode()']");
                if (isTerminated) {
                    execCode.disabled = true;
                    execCode.classList.add("bg-base-200", "cursor-not-allowed");
                    runButton.disabled = true;
                    runButton.classList.add("opacity-50", "cursor-not-allowed");
                } else {
                    execCode.disabled = false;
                    execCode.classList.remove("bg-base-200", "cursor-not-allowed");
                    runButton.disabled = false;
                    runButton.classList.remove("opacity-50", "cursor-not-allowed");
                }

                // Handle logs tab for interactive sandboxes
                const logsTab = document.getElementById("logs-tab");
                if (sb.interactive) {
                    logsTab.disabled = true;
                    logsTab.classList.add("opacity-50", "cursor-not-allowed");
                    logsTab.title = "Logs are disabled for interactive sandboxes";
                    // If currently on logs tab, switch to exec tab
                    if (currentTab === "logs") {
                        switchTab("exec");
                    }
                } else {
                    logsTab.disabled = false;
                    logsTab.classList.remove("opacity-50", "cursor-not-allowed");
                    logsTab.title = "";
                }

                // Handle terminal tab for non-interactive sandboxes
                const terminalTab = document.getElementById("terminal-tab");
                if (!sb.interactive) {
                    terminalTab.disabled = true;
                    terminalTab.classList.add("opacity-50", "cursor-not-allowed");
                    terminalTab.title = "Terminal is only available for interactive sandboxes";
                    // If currently on terminal tab, switch to exec tab
                    if (currentTab === "terminal") {
                        switchTab("exec");
                    }
                } else {
                    terminalTab.disabled = false;
                    terminalTab.classList.remove("opacity-50", "cursor-not-allowed");
                    terminalTab.title = "";
                }

                // Load historical command executions
                await loadCommandExecutions();
                
                // Start fetching logs if we're on the logs tab
                if (!document.getElementById("logs-view").classList.contains("hidden")) {
                    stopLogsFetching();
                    startLogsFetching();
                }

                // Initialize HTTP view if we're on the HTTP tab
                if (!document.getElementById("http-view").classList.contains("hidden")) {
                    initializeHttpView();
                }

                // Connect terminal if we're on the terminal tab
                if (!document.getElementById("terminal-view").classList.contains("hidden")) {
                    connectTerminal();
                }

                // Show file explorer and load root directory
                document.getElementById("file-explorer").classList.remove("hidden");
                loadFileSystem('/');

                // Automatically switch to appropriate tab based on sandbox type
                if (sb.interactive) {
                    switchTab('terminal');
                } else {
                    switchTab('logs');
                }
            } catch (error) {
                showError(error.message);
            }
        }

        async function loadCommandExecutions() {
            if (!selectedSandbox) return;
            
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}/execution-logs`);
                if (!response.ok) throw new Error("Failed to fetch command executions");
                const data = await response.json();
                
                const resultsContainer = document.getElementById("exec-results");
                resultsContainer.innerHTML = ''; // Clear existing content
                
                // Display executions in chronological order (newest first)
                for (const execution of data.executions) {
                    // Create a container div for this execution
                    const containerDiv = document.createElement("div");
                    containerDiv.className = "relative group";
                    
                    // Create the result div for this execution
                    const resultDiv = document.createElement("pre");
                    resultDiv.classList = "bg-base-200 text-primary text-wrap p-2 rounded shadow my-2 overflow-auto";
                    
                    // Add command header
                    resultDiv.textContent = `> ${execution.command}`;
                    
                    // Add logs for this execution
                    for (const log of execution.logs) {
                        const logLine = document.createElement("div");
                        logLine.className = log.fd === 2 ? "text-error" : "text-primary";
                        logLine.textContent = log.content;
                        resultDiv.appendChild(logLine);
                    }
                    
                    // Add exit code if available
                    if (execution.exit_code != 0) {
                        const exitLine = document.createElement("div");
                        exitLine.textContent = `ðŸ›‘ Process exited with code ${execution.exit_code}`;
                        resultDiv.appendChild(exitLine);
                    }
                    
                    // Create copy button
                    const copyButton = document.createElement("button");
                    copyButton.className = "absolute top-2 right-2 btn btn-ghost btn-xs opacity-0 group-hover:opacity-100 transition-opacity duration-200";
                    copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" /></svg>';
                    copyButton.onclick = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        // Get all text content from the result div, excluding the command line
                        const textToCopy = Array.from(resultDiv.childNodes)
                            .filter(node => !node.textContent.startsWith('>'))
                            .map(node => node.textContent)
                            .join('\n')
                            .trim();
                        navigator.clipboard.writeText(textToCopy);
                    };
                    
                    // Add elements to container
                    containerDiv.appendChild(resultDiv);
                    containerDiv.appendChild(copyButton);
                    
                    // Add container to results
                    resultsContainer.appendChild(containerDiv);
                }
                
                // Scroll to bottom
                setTimeout(function() {
                    resultsContainer.scrollTop = resultsContainer.scrollHeight;
                }, 10);
            } catch (error) {
                console.error("Error loading command executions:", error);
                document.getElementById("exec-results").innerHTML = 
                    `<div class="text-error">Error loading command executions: ${error.message}</div>`;
            }
        }

        const SANDBOX_EXAMPLES = {
            redis: {
                image: 'redis',
                label: 'Redis',
                args: ['redis-server'],
                env: {},
                interactive: false
            },
            nginx: {
                image: 'nginx',
                label: 'Nginx',
                args: [],
                env: {},
                interactive: false
            },
            firefox: {
                image: 'jlesage/firefox',
                label: 'Firefox',
                args: [],
                env: {},
                interactive: false
            },
            bash: {
                image: 'bash',
                label: 'Bash',
                args: [],
                env: {},
                interactive: true
            },
            fresh: {
                image: 'denoland/deno',
                label: 'Fresh (Deno)',
                args: ['bash', '-c', 'deno run -A -r https://fresh.deno.dev fresh-demo --tailwind --vscode && cd fresh-demo && deno task start; exec bash'],
                env: {},
                interactive: true
            }
        };

        function populateExample(example) {
            if (!example) {
                // Clear all fields
                document.getElementById('sandbox-image').value = '';
                document.getElementById('sandbox-label').value = '';
                document.getElementById('sandbox-hostname').value = '';
                document.getElementById('sandbox-args').value = '';
                document.getElementById('sandbox-env').value = '';
                document.getElementById('sandbox-interactive').checked = false;
                return;
            }

            const exampleData = SANDBOX_EXAMPLES[example];
            document.getElementById('sandbox-image').value = exampleData.image;
            document.getElementById('sandbox-label').value = exampleData.label;
            document.getElementById('sandbox-hostname').value = '';
            document.getElementById('sandbox-args').value = exampleData.args.join('\n');
            document.getElementById('sandbox-env').value = Object.entries(exampleData.env)
                .map(([key, value]) => `${key}=${value}`)
                .join('\n');
            document.getElementById('sandbox-interactive').checked = exampleData.interactive;
        }

        function setCreateLoading(isLoading) {
            const submitBtn = document.getElementById('create-submit-btn');
            const cancelBtn = document.getElementById('create-cancel-btn');
            const spinner = document.getElementById('create-spinner');
            
            submitBtn.disabled = isLoading;
            cancelBtn.disabled = isLoading;
            
            if (isLoading) {
                spinner.classList.remove('hidden');
                submitBtn.classList.add('opacity-75', 'cursor-not-allowed');
                cancelBtn.classList.add('opacity-75', 'cursor-not-allowed');
            } else {
                spinner.classList.add('hidden');
                submitBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                cancelBtn.classList.remove('opacity-75', 'cursor-not-allowed');
            }
        }

        async function createSandbox() {
            hideError();
            const image = document.getElementById('sandbox-image').value.trim();
            const label = document.getElementById('sandbox-label').value.trim();
            const hostname = document.getElementById('sandbox-hostname').value.trim();
            const interactive = document.getElementById('sandbox-interactive').checked;
            if (!image || !label) return showError("Please enter a Docker image and a label.");

            // Parse environment variables
            const envText = document.getElementById('sandbox-env').value.trim();
            const env = {};
            if (envText) {
                envText.split('\n').forEach(line => {
                    line = line.trim();
                    if (line) {
                        const [key, ...valueParts] = line.split('=');
                        const value = valueParts.join('='); // Rejoin in case value contains =
                        if (key && value) {
                            env[key.trim()] = value.trim();
                        }
                    }
                });
            }

            // Parse container arguments
            const argsText = document.getElementById('sandbox-args').value.trim();
            const args = argsText ? argsText.split('\n').filter(line => line.trim()) : [];

            try {
                setCreateLoading(true);
                const response = await fetch("/sandboxes", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ image, label, hostname, env, args, interactive })
                });

                if (!response.ok) throw new Error(await response.text());
                const newSandbox = await response.json();
                closeCreateModal();
                loadSandboxes();
                // Select the newly created sandbox
                selectSandbox(newSandbox.id);
            } catch (error) {
                showError(error.message);
                closeCreateModal();
            } finally {
                setCreateLoading(false);
            }

            // Clear the form fields
            document.getElementById('sandbox-image').value = '';
            document.getElementById('sandbox-label').value = '';
            document.getElementById('sandbox-hostname').value = '';
            document.getElementById('sandbox-args').value = '';
            document.getElementById('sandbox-env').value = '';
        }

        async function forkSandbox() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            try {
                const label = prompt("Enter label for the forked sandbox:");
                if (!label) return;

                // Get the fork button and show loading state
                const forkButton = document.querySelector('button[onclick="forkSandbox()"]');
                const originalContent = forkButton.innerHTML;
                forkButton.innerHTML = '<span class="loading loading-spinner loading-sm"></span>';
                forkButton.disabled = true;

                const response = await fetch(`/sandboxes/${selectedSandbox}/fork`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ label })
                });

                if (!response.ok) throw new Error(await response.text());
                loadSandboxes();
            } catch (error) {
                showError(error.message);
            } finally {
                // Restore the fork button
                const forkButton = document.querySelector('button[onclick="forkSandbox()"]');
                forkButton.innerHTML = '<img src="/static/images/icon-fork.svg" alt="Fork" class="w-5 h-5">';
                forkButton.disabled = false;
            }
        }

        async function executeCode() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            const codeInput = document.getElementById("exec-code");
            const code = codeInput.value.trim();
            if (!code) return showError("Enter a command.");

            // Clear input field after pressing run
            codeInput.value = "";

            // Create a new result div for this execution
            const resultDiv = document.createElement("pre");
            resultDiv.classList = "bg-base-200 text-primary text-wrap p-2 rounded shadow my-2 overflow-auto";
            // Escape the code before displaying
            resultDiv.textContent = `> ${code}`;
            document.getElementById("exec-results").append(resultDiv);

            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}/execute?stream=true`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ code })
                });

                if (!response.ok || !response.body) throw new Error("Failed to stream execution.");

                // Stream processing
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });

                    // Process complete lines (JSON objects)
                    let lines = buffer.split("\n");
                    buffer = lines.pop(); // Save incomplete line for next read

                    for (let line of lines) {
                        try {
                            const data = JSON.parse(line.trim());
                            if (data.type === "stdout" || data.type === "stderr") {
                                // Append text safely
                                resultDiv.appendChild(document.createTextNode("\n" + data.output));
                            } else if (data.type === "exit" && data.exit_code != 0) {
                                resultDiv.innerHTML += `\nðŸ›‘ ${data.output}`;
                            }
                        } catch (err) {
                            console.warn("Error parsing streamed JSON:", line, err);
                        }
                    }

                    // Scroll to the bottom when new results appear
                    document.getElementById("exec-results").scrollTop = document.getElementById("exec-results").scrollHeight;
                }
            } catch (error) {
                showError(error.message);
            }
        }

        async function deleteSandbox() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            if (!confirm("Are you sure you want to stop this sandbox?")) return;
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}`, { method: "DELETE" });
                if (!response.ok) throw new Error(await response.text());
                
                // Reset UI state
                selectedSandbox = null;
                const sandboxInfo = document.getElementById("sandbox-info");
                sandboxInfo.innerText = "Select a sandbox to view status.";
                sandboxInfo.removeAttribute("data-url");
                document.getElementById("sandbox-actions").classList.add("hidden");
                
                // Clear all tab contents
                document.getElementById("exec-results").innerHTML = "<p class='text-base-content/70'>Execution results will appear here.</p>";
                document.getElementById("sandbox-logs").innerHTML = "<p class='text-base-content/70'>Sandbox logs will appear here.</p>";
                document.getElementById("exec-code").value = "";
                document.getElementById("exec-code").disabled = false;
                document.getElementById("exec-code").classList.remove("bg-base-200", "cursor-not-allowed");
                
                // Reset terminal
                disconnectTerminal();
                if (term) {
                    term.dispose();
                    term = null;
                }
                
                // Reset HTTP view
                document.getElementById("sandbox-iframe").src = "";
                document.getElementById("browser-url").value = "";
                
                // Reset file explorer
                document.getElementById("file-explorer").classList.add("hidden");
                document.getElementById("file-list").innerHTML = "<p class='text-base-content/70 p-2'>Select a sandbox to view files.</p>";
                document.getElementById("current-path").value = "";
                
                // Switch back to exec tab
                switchTab('exec');
                
                // Refresh sandbox list
                loadSandboxes();
            } catch (error) {
                showError(error.message);
            }
        }

        async function renameSandbox() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            const newLabel = prompt("Enter new label:");
            if (!newLabel) return;
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}`, {
                    method: "PATCH",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ label: newLabel })
                });

                if (!response.ok) throw new Error(await response.text());
                loadSandboxes();
            } catch (error) {
                showError(error.message);
            }
        }

        function handleEnter(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault();
                executeCode();
            }
        }

        function showError(message) {
            let errorMessage = message;
            try {
                const jsonError = JSON.parse(message);
                if (jsonError.detail) {
                    errorMessage = `<pre class="font-mono text-sm whitespace-pre-wrap">${jsonError.detail}</pre>`;
                }
            } catch (e) {
                // Not JSON, use message as is
            }
            document.getElementById("error-message").innerHTML = errorMessage;
            document.getElementById("error-alert").classList.remove("hidden");
        }

        function hideError() {
            document.getElementById("error-alert").classList.add("hidden");
        }

        function openCreateModal() { 
            const modal = document.getElementById("create-modal");
            modal.showModal();
            // Use a small timeout to ensure the modal is fully rendered
            setTimeout(() => {
                document.getElementById("sandbox-image").focus();
            }, 100);
        }
        function closeCreateModal() { document.getElementById("create-modal").close() }

        function switchTab(tab) {
            if (currentTab === tab) {
                return; // Ignore if clicking the same tab
            }
            currentTab = tab; // Update current tab

            // Update tab styling
            document.getElementById("exec-tab").classList.toggle("tab-active", tab === "exec");
            document.getElementById("terminal-tab").classList.toggle("tab-active", tab === "terminal");
            document.getElementById("logs-tab").classList.toggle("tab-active", tab === "logs");
            document.getElementById("http-tab").classList.toggle("tab-active", tab === "http");

            // Show/hide content
            document.getElementById("exec-view").classList.toggle("hidden", tab !== "exec");
            const terminalView = document.getElementById("terminal-view");
            const terminal = document.getElementById("terminal");
            terminalView.classList.toggle("hidden", tab !== "terminal");
            terminal.classList.toggle("hidden", tab !== "terminal");
            document.getElementById("logs-view").classList.toggle("hidden", tab !== "logs");
            document.getElementById("http-view").classList.toggle("hidden", tab !== "http");

            // Handle terminal tab
            if (tab === "terminal") {
                if (!term) {
                    initTerminal();
                }
                if (selectedSandbox && !terminalWs) {
                    connectTerminal();
                }
                // Focus the terminal
                if (term) {
                    term.focus();
                }
            }

            // Handle logs fetching
            if (tab === "logs" && selectedSandbox) {
                startLogsFetching();
            } else {
                stopLogsFetching();
            }

            // Handle HTTP tab initialization
            if (tab === "http" && selectedSandbox) {
                initializeHttpView();
            }
        }

        function initializeHttpView() {
            const urlBar = document.getElementById("browser-url");
            const sandboxInfo = document.getElementById("sandbox-info");
            const sandboxUrl = sandboxInfo.getAttribute("data-url");
            
            if (sandboxUrl) {
                urlBar.value = sandboxUrl;
            } else {
                urlBar.value = "";
            }
            
            navigateIframe();
        }

        function navigateIframe() {
            if (!selectedSandbox) return;
            
            // Get the sandbox URL from the sandbox info
            const sandboxInfo = document.getElementById("sandbox-info");
            const sandboxUrl = sandboxInfo.getAttribute("data-url");
            
            if (!sandboxUrl) {
                document.getElementById("sandbox-iframe").src = "";
                document.getElementById("browser-url").value = "https://";
                return;
            }
            
            // Use the browser URL value
            const browserUrl = document.getElementById("browser-url");
            const userPath = browserUrl.value;
            
            // If the user has modified the URL bar to a different domain, use that
            if (userPath.startsWith("http://") || userPath.startsWith("https://")) {
                document.getElementById("sandbox-iframe").src = userPath;
                return;
            }
            
            // Otherwise, use the sandbox URL
            document.getElementById("sandbox-iframe").src = sandboxUrl;
            browserUrl.value = sandboxUrl;
        }

        async function fetchLogs() {
            if (!selectedSandbox) return;
            
            // Create new AbortController for this stream
            logsAbortController = new AbortController();
            
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}/logs?stream=true`, {
                    signal: logsAbortController.signal
                });
                if (!response.ok || !response.body) throw new Error("Failed to stream logs");

                // Create logs container if it doesn't exist
                const logsContainer = document.getElementById("sandbox-logs");
                logsContainer.innerHTML = ''; // Clear existing content
                const preElement = document.createElement('pre');
                preElement.className = "text-sm font-mono whitespace-pre-wrap";
                logsContainer.appendChild(preElement);

                // Stream processing
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });

                    // Process complete lines
                    let lines = buffer.split("\n");
                    buffer = lines.pop() || ""; // Save incomplete line for next read

                    // Append each complete line to the logs
                    for (let line of lines) {
                        // Append text safely
                        preElement.appendChild(document.createTextNode(line + "\n"));
                        logsContainer.scrollTop = logsContainer.scrollHeight;
                    }
                }

                // Handle any remaining buffer
                if (buffer) {
                    preElement.appendChild(document.createTextNode(buffer));
                    logsContainer.scrollTop = logsContainer.scrollHeight;
                }
            } catch (error) {
                console.error("Error streaming logs:", error);
                document.getElementById("sandbox-logs").textContent = 
                    `Error streaming logs: ${error.message}`;
            }
        }

        function startLogsFetching() {
            stopLogsFetching(); // Clear any existing streams
            fetchLogs(); // Start streaming
        }

        function stopLogsFetching() {
            if (logsAbortController) {
                logsAbortController.abort();
                logsAbortController = null;
            }
        }

        function handleUrlEnter(event) {
            if (event.key === "Enter") {
                event.preventDefault();
                navigateIframe();
            }
        }

        async function loadUserInfo() {
            try {
                const response = await fetch('/auth/me');
                if (!response.ok) throw new Error('Failed to fetch user info');
                const user = await response.json();
                
                document.getElementById('user-avatar').src = user.avatar_url;
                document.getElementById('user-name').textContent = user.name;
            } catch (error) {
                console.error('Error loading user info:', error);
                // Redirect to login if unauthorized
                if (error.response?.status === 401) {
                    window.location.href = '/';
                }
            }
        }

        async function logout() {
            try {
                const response = await fetch('/auth/logout', { method: 'POST' });
                if (response.ok) {
                    window.location.href = '/';
                }
            } catch (error) {
                console.error('Error logging out:', error);
            }
        }

        async function togglePublic() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}`);
                if (!response.ok) throw new Error("Failed to fetch sandbox details.");
                const sb = await response.json();
                
                const newPublicState = !sb.is_public;
                const action = newPublicState ? "make public" : "make private";
                
                if (!confirm(`Are you sure you want to ${action} this sandbox?`)) return;
                
                const updateResponse = await fetch(`/sandboxes/${selectedSandbox}`, {
                    method: "PATCH",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ public: newPublicState })
                });

                if (!updateResponse.ok) throw new Error(await updateResponse.text());
                
                // Refresh sandbox details to update UI
                selectSandbox(selectedSandbox);
            } catch (error) {
                showError(error.message);
            }
        }

        async function togglePause() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            try {
                const sandboxInfo = document.getElementById("sandbox-info");
                const isPaused = sandboxInfo.getAttribute("data-status") === "paused";
                
                const response = await fetch(`/sandboxes/${selectedSandbox}/pause`, {
                    method: isPaused ? "DELETE" : "PUT"
                });
                
                if (!response.ok) throw new Error(await response.text());
                
                // Update the button text and sandbox status
                const pauseButton = document.getElementById("pause-toggle");
                if (isPaused) {
                    pauseButton.querySelector('img').src = '/static/images/icon-play.svg';
                    sandboxInfo.setAttribute("data-status", "running");
                } else {
                    pauseButton.querySelector('img').src = '/static/images/icon-pause.svg';
                    sandboxInfo.setAttribute("data-status", "paused");
                }
                
                // Refresh sandbox list to update status
                loadSandboxes();
                
                // Wait 500ms before refreshing the status bar
                setTimeout(() => {
                    selectSandbox(selectedSandbox);
                }, 500);
            } catch (error) {
                showError(error.message);
            }
        }

        // File System Explorer Functions
        function handlePathInput(event) {
            if (event.key === "Enter") {
                event.preventDefault();
                const path = document.getElementById("current-path").value.trim();
                // Ensure path starts with / and ends with / if it's a directory
                const normalizedPath = path.startsWith('/') ? path : '/' + path;
                loadFileSystem(normalizedPath);
                // Defocus the input after navigation
                event.target.blur();
            }
        }

        async function loadFileSystem(path = '/') {
            if (!selectedSandbox) return;
            
            try {
                // Normalize the path
                if (!path.startsWith('/')) {
                    path = '/' + path;
                }
                if (path !== '/' && !path.endsWith('/')) {
                    path += '/';
                }
                
                const response = await fetch(`/sandboxes/${selectedSandbox}/files${path}`);
                if (!response.ok) throw new Error("Failed to fetch file system");
                const data = await response.json();
                
                const fileList = document.getElementById("file-list");
                fileList.innerHTML = ''; // Clear existing content
                
                // Update current path display
                document.getElementById("current-path").value = path;
                
                // Sort entries: directories first, then files
                const entries = data.entries.sort((a, b) => {
                    if (a.is_dir === b.is_dir) return a.name.localeCompare(b.name);
                    return b.is_dir - a.is_dir;
                });
                
                // Create list items for each entry
                entries.forEach(entry => {
                    const li = document.createElement("li");
                    li.className = "break-words w-full line-clamp-4";
                    li.style.overflowWrap = "anywhere";
                    const a = document.createElement("a");
                    a.className = "flex items-center gap-2";
                    
                    // Add icon
                    const icon = document.createElement("img");
                    icon.src = entry.is_dir ? "/static/images/icon-folder.svg" : "/static/images/icon-file.svg";
                    icon.className = "h-4 w-4";
                    icon.alt = entry.is_dir ? "Folder" : "File";
                    
                    // Add name
                    const name = document.createElement("span");
                    name.textContent = entry.name;
                    
                    a.appendChild(icon);
                    a.appendChild(name);
                    
                    if (entry.is_dir) {
                        a.onclick = () => loadFileSystem(path + entry.name + '/');
                    } else {
                        a.onclick = () => viewFile(path + entry.name);
                    }
                    
                    li.appendChild(a);
                    fileList.appendChild(li);
                });
                
                // Show file explorer if it was hidden
                document.getElementById("file-explorer").classList.remove("hidden");
            } catch (error) {
                console.error("Error loading file system:", error);
                document.getElementById("file-list").innerHTML = 
                    `<li class="text-error p-2">Error: ${error.message}</li>`;
                // Keep the entered path in the input even if it failed
                document.getElementById("current-path").value = path;
            }
        }

        function navigateUp() {
            const currentPath = document.getElementById("current-path").value;
            if (currentPath === '/') return;
            
            const newPath = currentPath.split('/').slice(0, -2).join('/') + '/';
            loadFileSystem(newPath);
        }

        async function viewFile(path) {
            if (!selectedSandbox) return;
            
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}/files${path}`);
                if (!response.ok) throw new Error("Failed to fetch file");
                
                // Get the filename and content type
                const contentDisposition = response.headers.get('Content-Disposition');
                let filename = path.split('/').pop();
                if (contentDisposition) {
                    const matches = contentDisposition.match(/filename="(.+?)"/);
                    if (matches) filename = matches[1];
                }
                const contentType = response.headers.get('Content-Type') || 'application/octet-stream';
                
                // Get the file content as a blob
                const blob = await response.blob();
                
                // Create preview dialog
                const dialog = document.createElement("dialog");
                dialog.id = "preview-dialog";
                dialog.className = "modal";
                dialog.innerHTML = `
                    <div class="modal-box w-11/12 max-w-5xl max-h-[80vh] flex flex-col">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-semibold">${filename}</h3>
                            <div class="flex gap-2">
                                <button onclick="downloadFile(this)" class="btn btn-neutral">
                                    Download <span class="text-xs opacity-75">(âŒ˜S)</span>
                                </button>
                                <form method="dialog">
                                    <button class="btn btn-ghost">
                                        âœ– <span class="text-xs opacity-75">(Esc)</span>
                                    </button>
                                </form>
                            </div>
                        </div>
                        <div class="flex-grow overflow-auto">
                            <div id="preview-content" class="w-full h-full flex justify-center items-center">
                                Loading preview...
                            </div>
                        </div>
                    </div>
                    <form method="dialog" class="modal-backdrop">
                        <button>close</button>
                    </form>
                `;
                
                // Store the blob and filename in the dialog for download
                dialog.dataset.blob = URL.createObjectURL(blob);
                dialog.dataset.filename = filename;
                
                // Add dialog to document
                document.body.appendChild(dialog);
                
                // Add keyboard event listener
                const handleKeyDown = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                        e.preventDefault(); // Prevent browser save dialog
                        downloadFile(dialog.querySelector('button[onclick="downloadFile(this)"]'));
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
                
                // Store the event listener reference in the dialog's closure
                dialog.handleKeyDown = handleKeyDown;
                
                // Handle preview based on content type
                const previewContent = dialog.querySelector('#preview-content');
                
                if (contentType.startsWith('image/')) {
                    // Image preview
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(blob);
                    img.className = 'max-w-full max-h-[60vh] object-contain';
                    img.onload = () => URL.revokeObjectURL(img.src);
                    previewContent.innerHTML = '';
                    previewContent.appendChild(img);
                    
                } else if (contentType.startsWith('video/')) {
                    // Video preview
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(blob);
                    video.controls = true;
                    video.className = 'max-w-full max-h-[60vh]';
                    video.onload = () => URL.revokeObjectURL(video.src);
                    previewContent.innerHTML = '';
                    previewContent.appendChild(video);
                    
                } else if (contentType.startsWith('text/') || 
                          contentType === 'application/json' || 
                          contentType === 'application/xml' ||
                          filename.endsWith('.ts') ||
                          filename.endsWith('.tsx') ||
                          filename.endsWith('.js') ||
                          filename.endsWith('.jsx') ||
                          filename.endsWith('.conf') ||
                          filename.endsWith('.ini') ||
                          filename.endsWith('.cfg') ||
                          filename.endsWith('.yml') ||
                          filename.endsWith('.yaml') ||
                          filename.endsWith('.toml') ||
                          !filename.includes('.')) {
                    // Text preview
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const pre = document.createElement('pre');
                        pre.className = 'bg-base-200 p-4 rounded overflow-auto font-mono text-sm';
                        pre.textContent = e.target.result;
                        previewContent.innerHTML = '';
                        previewContent.appendChild(pre);
                    };
                    reader.readAsText(blob);
                    
                } else {
                    // Unsupported type
                    previewContent.innerHTML = `
                        <div class="text-center text-base-content/70">
                            <p>Preview not available for this file type.</p>
                            <p class="text-sm">${contentType}</p>
                        </div>
                    `;
                }
                
                // Show the dialog
                dialog.showModal();
                
            } catch (error) {
                console.error("Error viewing file:", error);
                showError(`Failed to view file: ${error.message}`);
            }
        }
        
        function downloadFile(button) {
            const dialog = document.getElementById('preview-dialog');
            const blobUrl = dialog.dataset.blob;
            const filename = dialog.dataset.filename;
            
            // Create temporary anchor for download
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = filename;
            a.style.display = 'none';
            
            // Add to document, click it, and remove it
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // Add this function after the loadFileSystem function
        async function handleFileUpload(event) {
            if (!selectedSandbox) return;
            
            const files = event.target.files;
            if (!files || files.length === 0) return;
            
            const currentPath = document.getElementById("current-path").value;
            
            // Create FormData to send files
            const formData = new FormData();
            
            // Add each file to FormData
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                // Get the relative path within the directory
                const relativePath = file.webkitRelativePath || file.name;
                formData.append('files', file, relativePath);
            }
            
            try {
                // Upload to the current path in the sandbox
                const response = await fetch(`/sandboxes/${selectedSandbox}/files${currentPath}`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(await response.text());
                }
                
                // Refresh the current directory to show new files
                loadFileSystem(currentPath);
                
                // Clear the file input
                event.target.value = '';
                
            } catch (error) {
                console.error("Error uploading files:", error);
                showError(`Failed to upload files: ${error.message}`);
            }
        }

        // Connect to SSE when page loads
        document.addEventListener('DOMContentLoaded', function() {
            connectSSE();
            loadSandboxes();
            loadUserInfo();
            
            // Add event listener for file upload
            document.getElementById('file-upload').addEventListener('change', handleFileUpload);
            
            // Add event listener to iframe to update URL bar when URL changes
            const iframe = document.getElementById("sandbox-iframe");
            iframe.addEventListener('load', function() {
                const browserUrl = document.getElementById("browser-url");
                const currentUrl = iframe.contentWindow.location.href;
                browserUrl.value = currentUrl;
            });
        });

        // Clean up SSE connection when page unloads
        window.addEventListener('beforeunload', function() {
            if (eventSource) {
                eventSource.close();
            }
        });

        // Add global keyboard shortcut handler
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
                e.preventDefault();
                const pathInput = document.getElementById('current-path');
                if (pathInput) {
                    pathInput.focus();
                    pathInput.select();
                }
            }
            // Add Ctrl-N/Cmd-N shortcut for Create Sandbox
            if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
                e.preventDefault();
                openCreateModal();
            }
        });

        // Add these new functions after the handleFileUpload function
        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            // Add visual feedback to the file list
            const fileList = document.getElementById('file-list');
            fileList.classList.remove('bg-base-100');
            fileList.classList.add('bg-base-300');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            // Remove visual feedback from the file list
            const fileList = document.getElementById('file-list');
            fileList.classList.remove('bg-base-300');
            fileList.classList.add('bg-base-100');
        }

        async function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Remove visual feedback from the file list
            const fileList = document.getElementById('file-list');
            fileList.classList.remove('bg-base-300');
            fileList.classList.add('bg-base-100');
            
            if (!selectedSandbox) {
                showError("Select a sandbox first.");
                return;
            }
            
            const items = event.dataTransfer.items;
            if (!items || items.length === 0) return;
            
            const currentPath = document.getElementById("current-path").value;
            const formData = new FormData();
            
            // Process each dropped item
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.kind === 'file') {
                    const entry = item.webkitGetAsEntry();
                    if (entry) {
                        await processEntry(entry, formData, '');
                    }
                }
            }
            
            if (formData.getAll('files').length === 0) return;
            
            try {
                // Upload to the current path in the sandbox
                const response = await fetch(`/sandboxes/${selectedSandbox}/files${currentPath}`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(await response.text());
                }
                
                // Refresh the current directory to show new files
                loadFileSystem(currentPath);
                
            } catch (error) {
                console.error("Error uploading files:", error);
                showError(`Failed to upload files: ${error.message}`);
            }
        }

        // Helper function to process directory entries recursively
        async function processEntry(entry, formData, path) {
            if (entry.isFile) {
                const file = await new Promise((resolve) => entry.file(resolve));
                formData.append('files', file, path + file.name);
            } else if (entry.isDirectory) {
                const reader = entry.createReader();
                const entries = await new Promise((resolve) => {
                    reader.readEntries(resolve);
                });
                
                for (const childEntry of entries) {
                    await processEntry(childEntry, formData, path + entry.name + '/');
                }
            }
        }

        // Add theme toggle function at the beginning of the script
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        }

        // Add theme initialization on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize theme from localStorage or system preference
            const savedTheme = localStorage.getItem('theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const initialTheme = savedTheme || (systemPrefersDark ? 'dark' : 'light');
            document.documentElement.setAttribute('data-theme', initialTheme);
            
            connectSSE();
            loadSandboxes();
            loadUserInfo();
            
            // Add event listener for file upload
            document.getElementById('file-upload').addEventListener('change', handleFileUpload);
            
            // Add event listener to iframe to update URL bar when URL changes
            const iframe = document.getElementById("sandbox-iframe");
            iframe.addEventListener('load', function() {
                const browserUrl = document.getElementById("browser-url");
                const currentUrl = iframe.contentWindow.location.href;
                browserUrl.value = currentUrl;
            });
        });

        // Add these new functions after the handleUrlEnter function
        function handleBrowserUrlEnter(event) {
            if (event.key === "Enter") {
                event.preventDefault();
                navigateFromBrowserUrl();
            }
        }

        function handleBrowserUrlBlur(event) {
            navigateFromBrowserUrl();
        }

        function navigateFromBrowserUrl() {
            const browserUrl = document.getElementById("browser-url");
            const url = browserUrl.value.trim();
            
            if (!url) return;
            
            // Add https:// if no protocol is specified
            let fullUrl = url;
            if (!url.startsWith("http://") && !url.startsWith("https://")) {
                fullUrl = "https://" + url;
            }
            
            // Update both URL bars
            document.getElementById("browser-url").value = fullUrl;
            
            // Navigate the iframe
            document.getElementById("sandbox-iframe").src = fullUrl;
        }
    </script>
</body>
</html>