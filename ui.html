<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandbox Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="h-screen flex bg-gray-100">

    <!-- Sidebar -->
    <div class="w-1/4 bg-white shadow-md p-4 flex flex-col">
        <h2 class="text-lg font-semibold mb-2">Sandboxes</h2>
        <button class="bg-blue-500 text-white px-4 py-2 rounded mb-4 w-full"
                onclick="openCreateModal()">
            ‚ûï Create Sandbox
        </button>
        <ul id="sandbox-tree" class="space-y-2 flex-grow overflow-auto"></ul>
    </div>

    <!-- Main Content -->
    <div class="w-3/4 flex flex-col p-4">
        <h2 class="text-lg font-semibold">Sandbox Console</h2>

        <!-- Sandbox Status Bar -->
        <div id="sandbox-status" class="bg-gray-300 text-gray-800 p-2 rounded mt-2 text-sm flex justify-between items-center">
            <span id="sandbox-info">Select a sandbox to view status.</span>
            <div id="sandbox-actions" class="hidden space-x-2">
                <button class="bg-gray-500 text-white px-3 py-1 rounded text-sm" onclick="renameSandbox()">‚úè Rename</button>
                <button class="bg-red-500 text-white px-3 py-1 rounded text-sm" onclick="deleteSandbox()">‚ùå Stop</button>
                <button class="bg-purple-500 text-white px-3 py-1 rounded text-sm" onclick="forkSandbox()">üîÄ Fork</button>
            </div>
        </div>

        <!-- Error Alert -->
        <div id="error-alert" class="hidden bg-red-500 text-white p-3 rounded mt-2">
            <span id="error-message"></span>
            <button class="float-right font-bold" onclick="hideError()">‚úñ</button>
        </div>

        <!-- Tabs -->
        <div class="flex border-b mt-4">
            <button id="exec-tab" 
                    class="px-4 py-2 text-sm font-medium rounded-t-lg bg-white border-t border-l border-r"
                    onclick="switchTab('exec')">
                Command Execution
            </button>
            <button id="logs-tab" 
                    class="px-4 py-2 text-sm font-medium rounded-t-lg border-t border-l border-r ml-2 bg-gray-100"
                    onclick="switchTab('logs')">
                Logs
            </button>
            <button id="http-tab" 
                    class="px-4 py-2 text-sm font-medium rounded-t-lg border-t border-l border-r ml-2 bg-gray-100"
                    onclick="switchTab('http')">
                HTTP
            </button>
        </div>

        <!-- Command Execution View -->
        <div id="exec-view" class="flex-grow flex flex-col">
            <div id="exec-results" class="flex-grow bg-gray-200 p-4 rounded mt-4 overflow-auto h-[60vh]">
                <p class="text-gray-500">Execution results will appear here.</p>
            </div>

            <!-- Command Input & Buttons -->
            <div class="bg-white p-4 shadow-md flex items-center gap-2">
                <textarea id="exec-code" class="border p-2 w-full h-12 resize-none" placeholder="Enter command..."
                          autocorrect="off" spellcheck="false" onkeydown="handleEnter(event)"></textarea>
                <button class="bg-green-500 text-white px-4 rounded" onclick="executeCode()">‚ñ∂ Run</button>
            </div>
        </div>

        <!-- Logs View -->
        <div id="logs-view" class="hidden flex-grow flex flex-col">
            <div id="sandbox-logs" class="flex-grow bg-gray-200 p-4 rounded mt-4 overflow-auto h-[calc(60vh+4rem)]">
                <p class="text-gray-500">Sandbox logs will appear here.</p>
            </div>
        </div>

        <!-- HTTP View -->
        <div id="http-view" class="hidden flex-grow flex flex-col">
            <div class="flex items-center gap-2 mt-4">
                <button class="text-gray-600 px-2 py-1 rounded hover:bg-gray-100" onclick="goBack()" title="Back">
                    ‚óÄ
                </button>
                <button class="text-gray-600 px-2 py-1 rounded hover:bg-gray-100" onclick="goForward()" title="Forward">
                    ‚ñ∂
                </button>
                <input type="text" id="url-bar" class="border p-2 flex-grow rounded" 
                       placeholder="Enter URL..." 
                       onkeydown="handleUrlEnter(event)">
                <button class="text-gray-600 px-2 py-1 rounded hover:bg-gray-100" onclick="refreshIframe()" title="Refresh">
                    ‚Üª
                </button>
                <button class="bg-blue-500 text-white px-4 py-2 rounded" onclick="navigateIframe()">Go</button>
            </div>
            <iframe id="sandbox-iframe" class="w-full flex-grow mt-4 border rounded" sandbox="allow-same-origin allow-scripts allow-forms"></iframe>
        </div>

    </div>

    <!-- Create Sandbox Modal -->
    <div id="create-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex justify-center items-center">
        <div class="bg-white p-6 rounded shadow-md w-1/3">
            <h2 class="text-lg font-semibold">Create Sandbox</h2>
            <label class="block mt-2">Docker Image:</label>
            <input type="text" id="sandbox-image" class="border p-2 w-full" placeholder="e.g., python:3">

            <label class="block mt-2">Label:</label>
            <input type="text" id="sandbox-label" class="border p-2 w-full" placeholder="Sandbox Label">

            <div class="mt-4 flex justify-end">
                <button class="bg-gray-500 text-white px-4 py-2 mr-2 rounded" onclick="closeCreateModal()">Cancel</button>
                <button class="bg-blue-500 text-white px-4 py-2 rounded" onclick="createSandbox()">Create</button>
            </div>
        </div>
    </div>

    <script>
        let selectedSandbox = null;
        let logsInterval = null;
        let logsAbortController = null;  // Add AbortController for logs streaming

        async function loadSandboxes() {
            try {
                const response = await fetch("/sandboxes");
                if (!response.ok) throw new Error("Failed to fetch sandboxes.");
                const data = await response.json();
                document.getElementById("sandbox-tree").innerHTML = renderTree(data.sandboxes);
            } catch (error) {
                showError(error.message);
            }
        }

        function renderTree(sandboxes, parentId = null) {
            let html = "";
            sandboxes.forEach(sb => {
                if (sb.parent_id === parentId) {
                    html += `
                        <li class="pl-4">
                            <button class="text-blue-500 font-semibold" onclick="selectSandbox('${sb.id}')">
                                üì¶ ${sb.label || "Unnamed"} [${sb.id.slice(0, 6)}]
                            </button>
                            <ul>${renderTree(sandboxes, sb.id)}</ul>
                        </li>
                    `;
                }
            });
            return html;
        }

        async function selectSandbox(sandboxId) {
            // Cancel any existing log streams before switching sandboxes
            if (logsAbortController) {
                logsAbortController.abort();
                logsAbortController = null;
            }
            
            selectedSandbox = sandboxId;
            try {
                const response = await fetch(`/sandboxes/${sandboxId}`);
                if (!response.ok) throw new Error("Failed to fetch sandbox details.");
                const sb = await response.json();

                document.getElementById("sandbox-info").innerText = 
                    `üì¶ ${sb.label || "Unnamed"} [${sb.id.slice(0, 6)}] | Status: ${sb.status} | IP: ${sb.ip_address || "N/A"}`;

                // Show action buttons
                document.getElementById("sandbox-actions").classList.remove("hidden");

                // Clear execution results when switching sandbox
                document.getElementById("exec-results").innerHTML = "";
                
                // Start fetching logs if we're on the logs tab
                if (document.getElementById("logs-view").classList.contains("hidden")) {
                    stopLogsFetching();
                } else {
                    startLogsFetching();
                }

                // Initialize HTTP view if we're on the HTTP tab
                if (!document.getElementById("http-view").classList.contains("hidden")) {
                    initializeHttpView();
                }
            } catch (error) {
                showError(error.message);
            }
        }

        async function createSandbox() {
            hideError();
            const image = document.getElementById('sandbox-image').value.trim();
            const label = document.getElementById('sandbox-label').value.trim();
            if (!image || !label) return showError("Please enter a Docker image and a label.");

            try {
                const response = await fetch("/sandboxes", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ image, label })
                });

                if (!response.ok) throw new Error(await response.text());
                closeCreateModal();
                loadSandboxes();
            } catch (error) {
                showError(error.message);
            }
        }

        async function forkSandbox() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            try {
                const label = prompt("Enter label for the forked sandbox:");
                if (!label) return;
                const response = await fetch(`/sandboxes/${selectedSandbox}/fork`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ label })
                });

                if (!response.ok) throw new Error(await response.text());
                loadSandboxes();
            } catch (error) {
                showError(error.message);
            }
        }

        async function executeCode() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            const codeInput = document.getElementById("exec-code");
            const code = codeInput.value.trim();
            if (!code) return showError("Enter a command.");

            // Clear input field after pressing run
            codeInput.value = "";

            // Create a new result div for this execution
            const resultDiv = document.createElement("pre");
            resultDiv.classList = "bg-black text-green-400 text-wrap p-2 rounded shadow my-2 overflow-auto";
            resultDiv.innerHTML = `> ${code}`;
            document.getElementById("exec-results").append(resultDiv);

            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}/execute?stream=true`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ code })
                });

                if (!response.ok || !response.body) throw new Error("Failed to stream execution.");

                // Stream processing
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });

                    // Process complete lines (JSON objects)
                    let lines = buffer.split("\n");
                    buffer = lines.pop(); // Save incomplete line for next read

                    for (let line of lines) {
                        try {
                            const data = JSON.parse(line.trim());
                            if (data.type === "stdout" || data.type === "stderr") {
                                resultDiv.innerHTML += `\n${data.output}`;
                            } else if (data.type === "exit") {
                                //resultDiv.innerHTML += `\nüõë ${data.output}`;
                            }
                        } catch (err) {
                            console.warn("Error parsing streamed JSON:", line, err);
                        }
                    }

                    // Scroll to the bottom when new results appear
                    document.getElementById("exec-results").scrollTop = document.getElementById("exec-results").scrollHeight;
                }
            } catch (error) {
                showError(error.message);
            }
        }

        async function deleteSandbox() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            if (!confirm("Are you sure you want to stop this sandbox?")) return;
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}`, { method: "DELETE" });
                if (!response.ok) throw new Error(await response.text());
                loadSandboxes();
                document.getElementById("sandbox-status").innerText = "Select a sandbox to view status.";
                document.getElementById("sandbox-actions").classList.add("hidden");
            } catch (error) {
                showError(error.message);
            }
        }

        async function renameSandbox() {
            if (!selectedSandbox) return showError("Select a sandbox first.");
            const newLabel = prompt("Enter new label:");
            if (!newLabel) return;
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}`, {
                    method: "PATCH",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ label: newLabel })
                });

                if (!response.ok) throw new Error(await response.text());
                loadSandboxes();
            } catch (error) {
                showError(error.message);
            }
        }

        function handleEnter(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault();
                executeCode();
            }
        }

        function showError(message) {
            document.getElementById("error-message").innerText = message;
            document.getElementById("error-alert").classList.remove("hidden");
        }

        function hideError() {
            document.getElementById("error-alert").classList.add("hidden");
        }

        function openCreateModal() { document.getElementById("create-modal").classList.remove("hidden"); }
        function closeCreateModal() { document.getElementById("create-modal").classList.add("hidden"); }

        function switchTab(tab) {
            // Update tab styling
            document.getElementById("exec-tab").classList.toggle("bg-white", tab === "exec");
            document.getElementById("exec-tab").classList.toggle("bg-gray-100", tab !== "exec");
            document.getElementById("logs-tab").classList.toggle("bg-white", tab === "logs");
            document.getElementById("logs-tab").classList.toggle("bg-gray-100", tab !== "logs");
            document.getElementById("http-tab").classList.toggle("bg-white", tab === "http");
            document.getElementById("http-tab").classList.toggle("bg-gray-100", tab !== "http");

            // Show/hide content
            document.getElementById("exec-view").classList.toggle("hidden", tab !== "exec");
            document.getElementById("logs-view").classList.toggle("hidden", tab !== "logs");
            document.getElementById("http-view").classList.toggle("hidden", tab !== "http");

            // Handle logs fetching
            if (tab === "logs" && selectedSandbox) {
                startLogsFetching();
            } else {
                stopLogsFetching();
            }

            // Handle HTTP tab initialization
            if (tab === "http" && selectedSandbox) {
                initializeHttpView();
            }
        }

        function initializeHttpView() {
            const urlBar = document.getElementById("url-bar");
            urlBar.value = "/";
            navigateIframe();
        }

        function navigateIframe() {
            const userPath = document.getElementById("url-bar").value;
            // Remove leading slash if present to avoid double slashes
            const cleanPath = userPath.replace(/^\//, '');
            const fullUrl = `/sandboxes/${selectedSandbox}/proxy/${cleanPath}`;
            document.getElementById("sandbox-iframe").src = fullUrl;
        }

        async function fetchLogs() {
            if (!selectedSandbox) return;
            
            // Create new AbortController for this stream
            logsAbortController = new AbortController();
            
            try {
                const response = await fetch(`/sandboxes/${selectedSandbox}/logs?stream=true`, {
                    signal: logsAbortController.signal
                });
                if (!response.ok || !response.body) throw new Error("Failed to stream logs");

                // Create logs container if it doesn't exist
                const logsContainer = document.getElementById("sandbox-logs");
                logsContainer.innerHTML = '<pre class="text-sm font-mono whitespace-pre-wrap"></pre>';
                const preElement = logsContainer.querySelector('pre');

                // Stream processing
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });

                    // Process complete lines
                    let lines = buffer.split("\n");
                    buffer = lines.pop() || ""; // Save incomplete line for next read

                    // Append each complete line to the logs
                    for (let line of lines) {
                        preElement.innerHTML += `${line}\n`;
                        // Auto-scroll to bottom
                        logsContainer.scrollTop = logsContainer.scrollHeight;
                    }
                }

                // Handle any remaining buffer
                if (buffer) {
                    preElement.innerHTML += buffer;
                    logsContainer.scrollTop = logsContainer.scrollHeight;
                }
            } catch (error) {
                console.error("Error streaming logs:", error);
                document.getElementById("sandbox-logs").innerHTML = 
                    `<p class="text-red-500">Error streaming logs: ${error.message}</p>`;
            }
        }

        function startLogsFetching() {
            stopLogsFetching(); // Clear any existing streams
            fetchLogs(); // Start streaming
        }

        function stopLogsFetching() {
            if (logsAbortController) {
                logsAbortController.abort();
                logsAbortController = null;
            }
        }

        function handleUrlEnter(event) {
            if (event.key === "Enter") {
                event.preventDefault();
                navigateIframe();
            }
        }

        function goBack() {
            const iframe = document.getElementById("sandbox-iframe");
            iframe.contentWindow.history.back();
        }

        function goForward() {
            const iframe = document.getElementById("sandbox-iframe");
            iframe.contentWindow.history.forward();
        }

        function refreshIframe() {
            const iframe = document.getElementById("sandbox-iframe");
            iframe.contentWindow.location.reload();
        }

        loadSandboxes();
    </script>
</body>
</html>